// Code generated from CreateParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // CreateParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type CreateParser struct {
	*antlr.BaseParser
}

var CreateParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func createparserParserInit() {
	staticData := &CreateParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'",
		"'AND'", "'ARRAY'", "'AS'", "'ASC'", "'ATTRIBUTE'", "'BEFORE'", "'BETWEEN'",
		"'BOTH'", "'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'",
		"'CHANGE'", "'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'",
		"'CONSTRAINT'", "'CONTINUE'", "'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT'",
		"'CURRENT_ROLE'", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", "'DATABASES'",
		"'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", "'DESC'", "'DESCRIBE'",
		"'DETERMINISTIC'", "'DIAGNOSTICS'", "'DISTINCT'", "'DISTINCTROW'", "'DROP'",
		"'EACH'", "'ELSE'", "'ELSEIF'", "'EMPTY'", "'ENCLOSED'", "'ENFORCED'",
		"'ESCAPED'", "'EXCEPT'", "'EXISTS'", "'EXIT'", "'EXPLAIN'", "'FALSE'",
		"'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'", "'FROM'", "'FULLTEXT'",
		"'GENERATED'", "'GET'", "'GRANT'", "'GROUP'", "'HAVING'", "'HIGH_PRIORITY'",
		"'HISTOGRAM'", "'IF'", "'IGNORE'", "'IGNORED'", "'IN'", "'INDEX'", "'INFILE'",
		"'INNER'", "'INOUT'", "'INSERT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'",
		"'JOIN'", "'KEY'", "'KEYS'", "'KILL'", "'LATERAL'", "'LEADING'", "'LEAVE'",
		"'LEFT'", "'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'",
		"'LOCKED'", "'LOOP'", "'LOW_PRIORITY'", "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'",
		"'MATCH'", "'MAXVALUE'", "'MINVALUE'", "'MODIFIES'", "'NATURAL'", "'NOT'",
		"'NO_WRITE_TO_BINLOG'", "'NULL'", "'NUMBER'", "'ON'", "'OPTIMIZE'",
		"'OPTION'", "'OPTIONAL'", "'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'",
		"'OUTER'", "'OUTFILE'", "'OVER'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'",
		"'PURGE'", "'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'",
		"'RELEASE'", "'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'",
		"'RESTRICT'", "'RETAIN'", "'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'",
		"'SCHEMA'", "'SCHEMAS'", "'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'",
		"'SIGNAL'", "'SKIP'", "'SKIP_QUERY_REWRITE'", "'SPATIAL'", "'SQL'",
		"'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", "'SQL_BIG_RESULT'",
		"'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'", "'STACKED'",
		"'STARTING'", "'STATEMENT'", "'STRAIGHT_JOIN'", "'TABLE'", "'TERMINATED'",
		"'THEN'", "'TO'", "'TRAILING'", "'TRIGGER'", "'TRUE'", "'UNDO'", "'UNION'",
		"'UNIQUE'", "'UNLOCK'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'",
		"'USING'", "'VALUES'", "'WHEN'", "'WHERE'", "'WHILE'", "'WITH'", "'WRITE'",
		"'XOR'", "'ZEROFILL'", "'TINYINT'", "'SMALLINT'", "'MEDIUMINT'", "'MIDDLEINT'",
		"'INT'", "'INT1'", "'INT2'", "'INT3'", "'INT4'", "'INT8'", "'INTEGER'",
		"'BIGINT'", "'REAL'", "'DOUBLE'", "'PRECISION'", "'FLOAT'", "'FLOAT4'",
		"'FLOAT8'", "'DECIMAL'", "'DEC'", "'NUMERIC'", "'DATE'", "'TIME'", "'TIMESTAMP'",
		"'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'", "'NVARCHAR'", "'NATIONAL'",
		"'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONG'",
		"'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'",
		"'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'",
		"'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'",
		"'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'",
		"'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'", "'JSON_ARRAY_APPEND'",
		"'JSON_ARRAY_INSERT'", "'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'", "'JSON_DEPTH'",
		"'JSON_EXTRACT'", "'JSON_INSERT'", "'JSON_KEYS'", "'JSON_LENGTH'", "'JSON_MERGE'",
		"'JSON_MERGE_PATCH'", "'JSON_MERGE_PRESERVE'", "'JSON_OBJECT'", "'JSON_OBJECTAGG'",
		"'JSON_OVERLAPS'", "'JSON_PRETTY'", "'JSON_QUOTE'", "'JSON_REMOVE'",
		"'JSON_REPLACE'", "'JSON_SCHEMA_VALID'", "'JSON_SCHEMA_VALIDATION_REPORT'",
		"'JSON_SEARCH'", "'JSON_SET'", "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'",
		"'JSON_TABLE'", "'JSON_TYPE'", "'JSON_UNQUOTE'", "'JSON_VALID'", "'JSON_VALUE'",
		"'NESTED'", "'ORDINALITY'", "'PATH'", "'AVG'", "'BIT_AND'", "'BIT_OR'",
		"'BIT_XOR'", "'COUNT'", "'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'",
		"'GROUP_CONCAT'", "'LAG'", "'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'",
		"'NTILE'", "'NTH_VALUE'", "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'",
		"'STD'", "'STDDEV'", "'STDDEV_POP'", "'STDDEV_SAMP'", "'SUM'", "'VAR_POP'",
		"'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'",
		"'LOCALTIME'", "'CURDATE'", "'CURTIME'", "'DATE_ADD'", "'DATE_SUB'",
		"'EXTRACT'", "'LOCALTIMESTAMP'", "'NOW'", "'POSITION'", "'SUBSTR'",
		"'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'",
		"'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'",
		"'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'",
		"'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'",
		"'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'",
		"'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'",
		"'CLIENT'", "'CLOSE'", "'CLUSTERING'", "'COALESCE'", "'CODE'", "'COLUMNS'",
		"'COLUMN_FORMAT'", "'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", "'COMPACT'",
		"'COMPLETION'", "'COMPRESSED'", "", "'CONCURRENT'", "'CONNECT'", "'CONNECTION'",
		"'CONSISTENT'", "'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'",
		"'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CYCLE'",
		"'CURSOR_NAME'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'",
		"'DEFINER'", "'DELAY_KEY_WRITE'", "'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'",
		"'DISCARD'", "'DISK'", "'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'",
		"'ENABLE'", "'ENCRYPTED'", "'ENCRYPTION'", "'ENCRYPTION_KEY_ID'", "'END'",
		"'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'", "'ERRORS'", "'ESCAPE'",
		"'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'",
		"'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'", "'FAILED_LOGIN_ATTEMPTS'",
		"'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'", "'FILTER'", "'FIRST'",
		"'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'", "'FOUND'", "'FULL'",
		"'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'", "'GROUP_REPLICATION'",
		"'HANDLER'", "'HASH'", "'HELP'", "'HISTORY'", "'HOST'", "'HOSTS'", "'IDENTIFIED'",
		"'IGNORE_SERVER_IDS'", "'IMPORT'", "'INCREMENT'", "'INDEXES'", "'INITIAL_SIZE'",
		"'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", "'INSTANCE'", "'INSTANT'",
		"'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", "'IPC'", "'ISOLATION'",
		"'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'", "'LAST'", "'LEAVES'",
		"'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'", "'LOGS'", "'MASTER'",
		"'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'", "'MASTER_DELAY'",
		"'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'", "'MASTER_LOG_POS'",
		"'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'", "'MASTER_SSL'",
		"'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", "'MASTER_SSL_CIPHER'",
		"'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", "'MASTER_TLS_VERSION'",
		"'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'", "'MAX_QUERIES_PER_HOUR'",
		"'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", "'MAX_USER_CONNECTIONS'",
		"'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'", "'MID'", "'MIGRATE'",
		"'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'", "'MYSQL_ERRNO'",
		"'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", "'NO'", "'NOCACHE'",
		"'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'", "'NOMINVALUE'", "'NOWAIT'",
		"'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'", "'OFFSET'", "'OF'",
		"'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'",
		"'OPTIONS'", "'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PAGE_COMPRESSED'",
		"'PAGE_COMPRESSION_LEVEL'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'",
		"'PARTITIONS'", "'PASSWORD'", "'PASSWORD_LOCK_TIME'", "'PHASE'", "'PLUGIN'",
		"'PLUGIN_DIR'", "'PLUGINS'", "'PORT'", "'PRECEDES'", "'PRECEDING'",
		"'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'", "'PROFILE'", "'PROFILES'",
		"'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'", "'RECOVER'", "'RECURSIVE'",
		"'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'",
		"'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'",
		"'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'",
		"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'",
		"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESTART'",
		"'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'", "'RETURNS'", "'REUSE'",
		"'ROLE'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'",
		"'RTREE'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SEQUENCE'",
		"'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'",
		"'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'",
		"'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'",
		"'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'",
		"'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'",
		"'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", "'STORED'",
		"'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'",
		"'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'",
		"'TABLE_TYPE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'",
		"'TRANSACTION'", "'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNBOUNDED'",
		"'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'",
		"'UNTIL'", "'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'",
		"'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'",
		"'WARNINGS'", "'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'",
		"'XA'", "'XML'", "'YES'", "'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'",
		"'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'",
		"'MICROSECOND'", "'ADMIN'", "'APPLICATION_PASSWORD_ADMIN'", "'AUDIT_ABORT_EXEMPT'",
		"'AUDIT_ADMIN'", "'AUTHENTICATION_POLICY_ADMIN'", "'BACKUP_ADMIN'",
		"'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'", "'CLONE_ADMIN'", "'CONNECTION_ADMIN'",
		"'ENCRYPTION_KEY_ADMIN'", "'EXECUTE'", "'FILE'", "'FIREWALL_ADMIN'",
		"'FIREWALL_EXEMPT'", "'FIREWALL_USER'", "'FLUSH_OPTIMIZER_COSTS'", "'FLUSH_STATUS'",
		"'FLUSH_TABLES'", "'FLUSH_USER_RESOURCES'", "'GROUP_REPLICATION_ADMIN'",
		"'INNODB_REDO_LOG_ARCHIVE'", "'INNODB_REDO_LOG_ENABLE'", "'INVOKE'",
		"'LAMBDA'", "'NDB_STORED_USER'", "'PASSWORDLESS_USER_ADMIN'", "'PERSIST_RO_VARIABLES_ADMIN'",
		"'PRIVILEGES'", "'PROCESS'", "'RELOAD'", "'REPLICATION_APPLIER'", "'REPLICATION_SLAVE_ADMIN'",
		"'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'", "'ROLE_ADMIN'", "'ROUTINE'",
		"'S3'", "'SERVICE_CONNECTION_ADMIN'", "", "'SET_USER_ID'", "'SHOW_ROUTINE'",
		"'SHUTDOWN'", "'SUPER'", "'SYSTEM_VARIABLES_ADMIN'", "'TABLES'", "'TABLE_ENCRYPTION_ADMIN'",
		"'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", "'ARMSCII8'", "'ASCII'",
		"'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'",
		"'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB18030'",
		"'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'",
		"'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'",
		"'MACCE'", "'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'",
		"'UTF16'", "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'",
		"'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'",
		"'MRG_MYISAM'", "'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'",
		"'TOKUDB'", "'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'",
		"'GEOMETRYCOLLECTION'", "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'",
		"'MULTILINESTRING'", "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'",
		"'ABS'", "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'",
		"'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'",
		"'ASYMMETRIC_DECRYPT'", "'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'",
		"'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'",
		"'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", "'CATALOG_NAME'",
		"'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", "'CHARSET'",
		"'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", "'CONCAT'",
		"'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", "'COS'",
		"'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'",
		"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'",
		"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'",
		"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'",
		"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'",
		"'ENVELOPE'", "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'",
		"'EXTRACTVALUE'", "'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'",
		"'FOUND_ROWS'", "'FROM_BASE64'", "'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'",
		"'GEOMCOLLFROMWKB'", "'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'",
		"'GEOMETRYFROMTEXT'", "'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'",
		"'GEOMFROMTEXT'", "'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'",
		"'GREATEST'", "'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'",
		"'INET6_ATON'", "'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'",
		"'INTERIORRINGN'", "'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'",
		"'ISSIMPLE'", "'IS_FREE_LOCK'", "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'",
		"'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'",
		"'LENGTH'", "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'",
		"'LINESTRINGFROMWKB'", "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'",
		"'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'",
		"'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", "'MBRDISJOINT'",
		"'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'",
		"'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'",
		"'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'",
		"'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'",
		"'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'",
		"'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'",
		"'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'",
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'",
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'",
		"'RANDOM'", "'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'",
		"'ROW_COUNT'", "'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'",
		"'SESSION_USER'", "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'",
		"'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'",
		"'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'",
		"'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'",
		"'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'",
		"'ST_DIMENSION'", "'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'",
		"'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'",
		"'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'",
		"'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'",
		"'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'",
		"'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'",
		"'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'",
		"'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", "'ST_NUMGEOMETRIES'",
		"'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", "'ST_NUMPOINTS'", "'ST_OVERLAPS'",
		"'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'",
		"'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", "'ST_SRID'",
		"'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", "'ST_TOUCHES'", "'ST_UNION'",
		"'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'",
		"'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'",
		"'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", "'TOUCHES'", "'TO_BASE64'",
		"'TO_DAYS'", "'TO_SECONDS'", "'TP_CONNECTION_ADMIN'", "'UCASE'", "'UNCOMPRESS'",
		"'UNCOMPRESSED_LENGTH'", "'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'",
		"'UPPER'", "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'",
		"'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", "'WEEKDAY'", "'WEEKOFYEAR'",
		"'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'", "'Y'", "'X'", "':='", "'+='",
		"'-='", "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'*'", "'/'",
		"'%'", "'+'", "'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'", "'~'",
		"'|'", "'&'", "'^'", "'.'", "'('", "')'", "','", "';'", "'@'", "'0'",
		"'1'", "'2'", "'''", "'\"'", "'`'", "':'",
	}
	staticData.SymbolicNames = []string{
		"", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT",
		"ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ARRAY", "AS", "ASC",
		"ATTRIBUTE", "BEFORE", "BETWEEN", "BOTH", "BUCKETS", "BY", "CALL", "CASCADE",
		"CASE", "CAST", "CHANGE", "CHARACTER", "CHECK", "COLLATE", "COLUMN",
		"CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS",
		"CURRENT", "CURRENT_ROLE", "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES",
		"DECLARE", "DEFAULT", "DELAYED", "DELETE", "DESC", "DESCRIBE", "DETERMINISTIC",
		"DIAGNOSTICS", "DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF",
		"EMPTY", "ENCLOSED", "ENFORCED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT",
		"EXPLAIN", "FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT",
		"GENERATED", "GET", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "HISTOGRAM",
		"IF", "IGNORE", "IGNORED", "IN", "INDEX", "INFILE", "INNER", "INOUT",
		"INSERT", "INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS",
		"KILL", "LATERAL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR",
		"LINES", "LOAD", "LOCK", "LOCKED", "LOOP", "LOW_PRIORITY", "MASTER_BIND",
		"MASTER_SSL_VERIFY_SERVER_CERT", "MATCH", "MAXVALUE", "MINVALUE", "MODIFIES",
		"NATURAL", "NOT", "NO_WRITE_TO_BINLOG", "NULL_LITERAL", "NUMBER", "ON",
		"OPTIMIZE", "OPTION", "OPTIONAL", "OPTIONALLY", "OR", "ORDER", "OUT",
		"OUTER", "OUTFILE", "OVER", "PARTITION", "PRIMARY", "PROCEDURE", "PURGE",
		"RANGE", "READ", "READS", "REFERENCES", "REGEXP", "RELEASE", "RENAME",
		"REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT", "RETAIN", "RETURN",
		"REVOKE", "RIGHT", "RLIKE", "SCHEMA", "SCHEMAS", "SELECT", "SET", "SEPARATOR",
		"SHOW", "SIGNAL", "SKIP_", "SKIP_QUERY_REWRITE", "SPATIAL", "SQL", "SQLEXCEPTION",
		"SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT",
		"SSL", "STACKED", "STARTING", "STATEMENT", "STRAIGHT_JOIN", "TABLE",
		"TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", "UNION",
		"UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", "USING", "VALUES",
		"WHEN", "WHERE", "WHILE", "WITH", "WRITE", "XOR", "ZEROFILL", "TINYINT",
		"SMALLINT", "MEDIUMINT", "MIDDLEINT", "INT", "INT1", "INT2", "INT3",
		"INT4", "INT8", "INTEGER", "BIGINT", "REAL", "DOUBLE", "PRECISION",
		"FLOAT", "FLOAT4", "FLOAT8", "DECIMAL", "DEC", "NUMERIC", "DATE", "TIME",
		"TIMESTAMP", "DATETIME", "YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL",
		"BINARY", "VARBINARY", "TINYBLOB", "BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB",
		"TINYTEXT", "TEXT", "MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING", "SERIAL",
		"YEAR_MONTH", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE",
		"HOUR_SECOND", "MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND",
		"HOUR_MICROSECOND", "DAY_MICROSECOND", "JSON_ARRAY", "JSON_ARRAYAGG",
		"JSON_ARRAY_APPEND", "JSON_ARRAY_INSERT", "JSON_CONTAINS", "JSON_CONTAINS_PATH",
		"JSON_DEPTH", "JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH",
		"JSON_MERGE", "JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_OBJECT",
		"JSON_OBJECTAGG", "JSON_OVERLAPS", "JSON_PRETTY", "JSON_QUOTE", "JSON_REMOVE",
		"JSON_REPLACE", "JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT",
		"JSON_SEARCH", "JSON_SET", "JSON_STORAGE_FREE", "JSON_STORAGE_SIZE",
		"JSON_TABLE", "JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "JSON_VALUE",
		"NESTED", "ORDINALITY", "PATH", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR",
		"COUNT", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "GROUP_CONCAT", "LAG",
		"LAST_VALUE", "LEAD", "MAX", "MIN", "NTILE", "NTH_VALUE", "PERCENT_RANK",
		"RANK", "ROW_NUMBER", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP",
		"SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", "CURRENT_DATE", "CURRENT_TIME",
		"CURRENT_TIMESTAMP", "LOCALTIME", "CURDATE", "CURTIME", "DATE_ADD",
		"DATE_SUB", "EXTRACT", "LOCALTIMESTAMP", "NOW", "POSITION", "SUBSTR",
		"SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP",
		"ACCOUNT", "ACTION", "AFTER", "AGGREGATE", "ALGORITHM", "ANY", "AT",
		"AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", "AUTO_INCREMENT", "AVG_ROW_LENGTH",
		"BEGIN", "BINLOG", "BIT", "BLOCK", "BOOL", "BOOLEAN", "BTREE", "CACHE",
		"CASCADED", "CHAIN", "CHANGED", "CHANNEL", "CHECKSUM", "PAGE_CHECKSUM",
		"CIPHER", "CLASS_ORIGIN", "CLIENT", "CLOSE", "CLUSTERING", "COALESCE",
		"CODE", "COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", "COMMENT", "COMMIT",
		"COMPACT", "COMPLETION", "COMPRESSED", "COMPRESSION", "CONCURRENT",
		"CONNECT", "CONNECTION", "CONSISTENT", "CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA",
		"CONSTRAINT_NAME", "CONTAINS", "CONTEXT", "CONTRIBUTORS", "COPY", "CPU",
		"CYCLE", "CURSOR_NAME", "DATA", "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH",
		"DEFINER", "DELAY_KEY_WRITE", "DES_KEY_FILE", "DIRECTORY", "DISABLE",
		"DISCARD", "DISK", "DO", "DUMPFILE", "DUPLICATE", "DYNAMIC", "ENABLE",
		"ENCRYPTED", "ENCRYPTION", "ENCRYPTION_KEY_ID", "END", "ENDS", "ENGINE",
		"ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN", "EVENT", "EVENTS", "EVERY",
		"EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE",
		"FAILED_LOGIN_ATTEMPTS", "FAST", "FAULTS", "FIELDS", "FILE_BLOCK_SIZE",
		"FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING", "FOLLOWS", "FOUND",
		"FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS", "GROUP_REPLICATION",
		"HANDLER", "HASH", "HELP", "HISTORY", "HOST", "HOSTS", "IDENTIFIED",
		"IGNORE_SERVER_IDS", "IMPORT", "INCREMENT", "INDEXES", "INITIAL_SIZE",
		"INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INSTANT", "INVISIBLE",
		"INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER", "JSON",
		"KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL", "LIST",
		"LOCAL", "LOGFILE", "LOGS", "MASTER", "MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY",
		"MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", "MASTER_LOG_FILE",
		"MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT", "MASTER_RETRY_COUNT",
		"MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT",
		"MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY",
		"MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR",
		"MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS",
		"MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT", "MID", "MIGRATE", "MIN_ROWS",
		"MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO", "NAME", "NAMES",
		"NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY", "NOCYCLE", "NOMAXVALUE",
		"NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE", "ODBC", "OFFLINE", "OFFSET",
		"OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", "ONLY", "OPEN", "OPTIMIZER_COSTS",
		"OPTIONS", "OWNER", "PACK_KEYS", "PAGE", "PAGE_COMPRESSED", "PAGE_COMPRESSION_LEVEL",
		"PARSER", "PARTIAL", "PARTITIONING", "PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME",
		"PHASE", "PLUGIN", "PLUGIN_DIR", "PLUGINS", "PORT", "PRECEDES", "PRECEDING",
		"PREPARE", "PRESERVE", "PREV", "PROCESSLIST", "PROFILE", "PROFILES",
		"PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER", "RECURSIVE", "REDO_BUFFER_SIZE",
		"REDUNDANT", "RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAYLOG",
		"REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE",
		"REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB",
		"REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION",
		"RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING", "RETURNS",
		"REUSE", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT",
		"RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE", "SERVER",
		"SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", "SNAPSHOT",
		"SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS",
		"SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE",
		"SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT",
		"STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", "STORED", "STRING",
		"SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUSPEND",
		"SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TABLE_TYPE", "TEMPORARY",
		"TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL",
		"TRIGGERS", "TRUNCATE", "UNBOUNDED", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE",
		"UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES",
		"VALIDATION", "VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT",
		"WARNINGS", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML",
		"YES", "EUR", "USA", "JIS", "ISO", "INTERNAL", "QUARTER", "MONTH", "DAY",
		"HOUR", "MINUTE", "WEEK", "SECOND", "MICROSECOND", "ADMIN", "APPLICATION_PASSWORD_ADMIN",
		"AUDIT_ABORT_EXEMPT", "AUDIT_ADMIN", "AUTHENTICATION_POLICY_ADMIN",
		"BACKUP_ADMIN", "BINLOG_ADMIN", "BINLOG_ENCRYPTION_ADMIN", "CLONE_ADMIN",
		"CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN", "EXECUTE", "FILE", "FIREWALL_ADMIN",
		"FIREWALL_EXEMPT", "FIREWALL_USER", "FLUSH_OPTIMIZER_COSTS", "FLUSH_STATUS",
		"FLUSH_TABLES", "FLUSH_USER_RESOURCES", "GROUP_REPLICATION_ADMIN", "INNODB_REDO_LOG_ARCHIVE",
		"INNODB_REDO_LOG_ENABLE", "INVOKE", "LAMBDA", "NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN",
		"PERSIST_RO_VARIABLES_ADMIN", "PRIVILEGES", "PROCESS", "RELOAD", "REPLICATION_APPLIER",
		"REPLICATION_SLAVE_ADMIN", "RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER",
		"ROLE_ADMIN", "ROUTINE", "S3", "SERVICE_CONNECTION_ADMIN", "SESSION_VARIABLES_ADMIN",
		"SET_USER_ID", "SHOW_ROUTINE", "SHUTDOWN", "SUPER", "SYSTEM_VARIABLES_ADMIN",
		"TABLES", "TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN",
		"ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257",
		"CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030",
		"GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R",
		"KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN",
		"SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32",
		"UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED",
		"INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA",
		"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE",
		"GEOMETRYCOLLECTION", "GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING",
		"MULTIPOINT", "MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE",
		"ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN",
		"ASTEXT", "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE",
		"ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN",
		"ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME",
		"CEIL", "CEILING", "CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH",
		"COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID",
		"CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY",
		"CREATE_ASYMMETRIC_PUB_KEY", "CREATE_DH_PARAMETERS", "CREATE_DIGEST",
		"CROSSES", "DATEDIFF", "DATE_FORMAT", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK",
		"DAYOFYEAR", "DECODE", "DEGREES", "DES_DECRYPT", "DES_ENCRYPT", "DIMENSION",
		"DISJOINT", "ELT", "ENCODE", "ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE",
		"ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE",
		"FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64",
		"FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB",
		"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT",
		"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB",
		"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT",
		"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA",
		"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL",
		"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED",
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH",
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB",
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD",
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS",
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES",
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT",
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT",
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB",
		"MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF",
		"NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", "OCT", "OCTET_LENGTH",
		"ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINTFROMTEXT",
		"POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT",
		"POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", "RAND", "RANDOM",
		"RANDOM_BYTES", "RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", "RPAD",
		"RTRIM", "SEC_TO_TIME", "SECONDARY_ENGINE_ATTRIBUTE", "SESSION_USER",
		"SHA", "SHA1", "SHA2", "SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX",
		"SQL_THREAD_WAIT_AFTER_GTIDS", "SQRT", "SRID", "STARTPOINT", "STRCMP",
		"STR_TO_DATE", "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_ASWKB", "ST_ASWKT",
		"ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", "ST_CROSSES", "ST_DIFFERENCE",
		"ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_ENDPOINT", "ST_ENVELOPE",
		"ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT", "ST_GEOMCOLLFROMTXT",
		"ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT", "ST_GEOMETRYCOLLECTIONFROMWKB",
		"ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB", "ST_GEOMETRYN", "ST_GEOMETRYTYPE",
		"ST_GEOMFROMTEXT", "ST_GEOMFROMWKB", "ST_INTERIORRINGN", "ST_INTERSECTION",
		"ST_INTERSECTS", "ST_ISCLOSED", "ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT",
		"ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT", "ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES",
		"ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS", "ST_NUMPOINTS", "ST_OVERLAPS",
		"ST_POINTFROMTEXT", "ST_POINTFROMWKB", "ST_POINTN", "ST_POLYFROMTEXT",
		"ST_POLYFROMWKB", "ST_POLYGONFROMTEXT", "ST_POLYGONFROMWKB", "ST_SRID",
		"ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_UNION", "ST_WITHIN",
		"ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX", "SUBTIME", "SYSTEM_USER",
		"TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIME_FORMAT", "TIME_TO_SEC",
		"TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS", "TP_CONNECTION_ADMIN",
		"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP",
		"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH",
		"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR",
		"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VAR_ASSIGN",
		"PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN",
		"AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE",
		"PLUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL",
		"EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP",
		"DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN", "ZERO_DECIMAL",
		"ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB",
		"REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING",
		"FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL",
		"DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL",
		"BIT_STRING", "STRING_CHARSET_NAME", "DIGTS", "DOT_ID", "ID", "COLUMN_NAME_ID",
		"TABLE_NAME_ID", "DB_NAME_ID", "REVERSE_QUOTE_ID", "HOST_IP_ADDRESS",
		"LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION",
	}
	staticData.RuleNames = []string{
		"stat", "create_table", "create_definition", "column_definition", "comment_defi",
		"key_defi", "show_length", "data_type", "key_part", "index_type", "index_option",
		"check_constraint_definition", "reference_definition", "reference_option",
		"table_options", "table_option", "partition_options", "partition_definition",
		"subpartition_definition", "tablespace_option", "tbl_name", "col_name",
		"tablespace_name", "index_name", "engine_name", "symbol", "literal",
		"string", "collation_name", "parser_name", "connect_string", "charset_name",
		"value", "length", "absolute_path_to_directory", "expr", "num", "max_number_of_rows",
		"min_number_of_rows", "partition_name", "logical_name", "data_dir",
		"index_dir", "column_list", "value_list",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 1165, 699, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1,
		3, 1, 96, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 102, 8, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 5, 1, 109, 8, 1, 10, 1, 12, 1, 112, 9, 1, 1, 1, 1, 1, 3,
		1, 116, 8, 1, 1, 1, 3, 1, 119, 8, 1, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 3, 3,
		126, 8, 3, 1, 3, 1, 3, 1, 3, 3, 3, 131, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 3, 3, 139, 8, 3, 3, 3, 141, 8, 3, 1, 3, 3, 3, 144, 8, 3, 1, 3,
		3, 3, 147, 8, 3, 1, 3, 3, 3, 150, 8, 3, 1, 3, 3, 3, 153, 8, 3, 1, 3, 3,
		3, 156, 8, 3, 1, 3, 3, 3, 159, 8, 3, 3, 3, 161, 8, 3, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 5, 3, 5, 169, 8, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 7, 1, 7, 1, 8, 1, 8, 3, 8, 181, 8, 8, 3, 8, 183, 8, 8, 1, 8, 3, 8, 186,
		8, 8, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 3, 10, 210, 8, 10, 1, 11, 1, 11, 3, 11, 214, 8, 11, 3, 11, 216,
		8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 224, 8, 11, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 5, 12, 232, 8, 12, 10, 12, 12, 12,
		235, 9, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 244,
		8, 12, 1, 12, 1, 12, 1, 12, 3, 12, 249, 8, 12, 1, 12, 1, 12, 1, 12, 3,
		12, 254, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		3, 13, 264, 8, 13, 1, 14, 1, 14, 1, 14, 5, 14, 269, 8, 14, 10, 14, 12,
		14, 272, 9, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 3, 15, 284, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 3, 15, 294, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		3, 15, 301, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 380, 8, 15, 10, 15,
		12, 15, 383, 9, 15, 1, 15, 1, 15, 3, 15, 387, 8, 15, 1, 16, 1, 16, 1, 16,
		3, 16, 392, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 400,
		8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 406, 8, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 417, 8, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 429,
		8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 436, 8, 16, 1, 16, 1,
		16, 3, 16, 440, 8, 16, 1, 16, 1, 16, 1, 16, 3, 16, 445, 8, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 453, 8, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 3, 16, 459, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 465, 8, 16,
		1, 16, 1, 16, 3, 16, 469, 8, 16, 3, 16, 471, 8, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 5, 16, 477, 8, 16, 10, 16, 12, 16, 480, 9, 16, 1, 16, 1, 16, 3,
		16, 484, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 3, 17, 496, 8, 17, 1, 17, 3, 17, 499, 8, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 3, 17, 506, 8, 17, 1, 17, 3, 17, 509, 8, 17, 1, 17,
		1, 17, 1, 17, 3, 17, 514, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 3, 17, 522, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		3, 17, 531, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3,
		17, 540, 8, 17, 1, 17, 1, 17, 1, 17, 3, 17, 545, 8, 17, 1, 17, 1, 17, 1,
		17, 3, 17, 550, 8, 17, 1, 17, 1, 17, 1, 17, 3, 17, 555, 8, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 5, 17, 561, 8, 17, 10, 17, 12, 17, 564, 9, 17, 1, 17,
		1, 17, 3, 17, 568, 8, 17, 1, 18, 1, 18, 1, 18, 3, 18, 573, 8, 18, 1, 18,
		1, 18, 1, 18, 3, 18, 578, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 3, 18, 586, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		3, 18, 595, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3,
		18, 604, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 609, 8, 18, 1, 18, 1, 18, 1,
		18, 3, 18, 614, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 619, 8, 18, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 628, 8, 19, 1, 19, 1, 19,
		3, 19, 632, 8, 19, 1, 20, 1, 20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 23, 1,
		23, 1, 24, 1, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 28, 1, 28,
		1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 32, 1, 32, 1, 33, 1, 33, 1,
		34, 1, 34, 1, 35, 1, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39,
		1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 5, 43, 686, 8, 43, 10, 43, 12, 43, 689, 9, 43, 1, 44,
		1, 44, 1, 44, 5, 44, 694, 8, 44, 10, 44, 12, 44, 697, 9, 44, 1, 44, 0,
		0, 45, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
		36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
		72, 74, 76, 78, 80, 82, 84, 86, 88, 0, 11, 1, 0, 196, 239, 2, 0, 13, 13,
		45, 45, 2, 0, 350, 350, 443, 443, 2, 0, 459, 459, 673, 673, 1, 0, 1138,
		1139, 2, 0, 81, 81, 388, 388, 3, 0, 430, 430, 469, 469, 521, 521, 2, 0,
		42, 42, 1138, 1139, 6, 0, 42, 42, 370, 370, 372, 372, 402, 402, 431, 431,
		573, 573, 1, 0, 1139, 1140, 1, 0, 787, 798, 766, 0, 90, 1, 0, 0, 0, 2,
		93, 1, 0, 0, 0, 4, 120, 1, 0, 0, 0, 6, 123, 1, 0, 0, 0, 8, 162, 1, 0, 0,
		0, 10, 168, 1, 0, 0, 0, 12, 172, 1, 0, 0, 0, 14, 176, 1, 0, 0, 0, 16, 182,
		1, 0, 0, 0, 18, 187, 1, 0, 0, 0, 20, 209, 1, 0, 0, 0, 22, 215, 1, 0, 0,
		0, 24, 225, 1, 0, 0, 0, 26, 263, 1, 0, 0, 0, 28, 265, 1, 0, 0, 0, 30, 386,
		1, 0, 0, 0, 32, 388, 1, 0, 0, 0, 34, 485, 1, 0, 0, 0, 36, 569, 1, 0, 0,
		0, 38, 631, 1, 0, 0, 0, 40, 633, 1, 0, 0, 0, 42, 635, 1, 0, 0, 0, 44, 637,
		1, 0, 0, 0, 46, 639, 1, 0, 0, 0, 48, 641, 1, 0, 0, 0, 50, 643, 1, 0, 0,
		0, 52, 645, 1, 0, 0, 0, 54, 647, 1, 0, 0, 0, 56, 649, 1, 0, 0, 0, 58, 651,
		1, 0, 0, 0, 60, 653, 1, 0, 0, 0, 62, 655, 1, 0, 0, 0, 64, 657, 1, 0, 0,
		0, 66, 659, 1, 0, 0, 0, 68, 661, 1, 0, 0, 0, 70, 663, 1, 0, 0, 0, 72, 665,
		1, 0, 0, 0, 74, 667, 1, 0, 0, 0, 76, 669, 1, 0, 0, 0, 78, 671, 1, 0, 0,
		0, 80, 673, 1, 0, 0, 0, 82, 675, 1, 0, 0, 0, 84, 677, 1, 0, 0, 0, 86, 679,
		1, 0, 0, 0, 88, 690, 1, 0, 0, 0, 90, 91, 3, 2, 1, 0, 91, 92, 5, 0, 0, 1,
		92, 1, 1, 0, 0, 0, 93, 95, 5, 33, 0, 0, 94, 96, 5, 649, 0, 0, 95, 94, 1,
		0, 0, 0, 95, 96, 1, 0, 0, 0, 96, 97, 1, 0, 0, 0, 97, 101, 5, 172, 0, 0,
		98, 99, 5, 77, 0, 0, 99, 100, 5, 114, 0, 0, 100, 102, 5, 60, 0, 0, 101,
		98, 1, 0, 0, 0, 101, 102, 1, 0, 0, 0, 102, 103, 1, 0, 0, 0, 103, 104, 3,
		40, 20, 0, 104, 105, 5, 1133, 0, 0, 105, 110, 3, 4, 2, 0, 106, 107, 5,
		1135, 0, 0, 107, 109, 3, 4, 2, 0, 108, 106, 1, 0, 0, 0, 109, 112, 1, 0,
		0, 0, 110, 108, 1, 0, 0, 0, 110, 111, 1, 0, 0, 0, 111, 113, 1, 0, 0, 0,
		112, 110, 1, 0, 0, 0, 113, 115, 5, 1134, 0, 0, 114, 116, 3, 28, 14, 0,
		115, 114, 1, 0, 0, 0, 115, 116, 1, 0, 0, 0, 116, 118, 1, 0, 0, 0, 117,
		119, 3, 32, 16, 0, 118, 117, 1, 0, 0, 0, 118, 119, 1, 0, 0, 0, 119, 3,
		1, 0, 0, 0, 120, 121, 3, 42, 21, 0, 121, 122, 3, 6, 3, 0, 122, 5, 1, 0,
		0, 0, 123, 125, 3, 14, 7, 0, 124, 126, 3, 12, 6, 0, 125, 124, 1, 0, 0,
		0, 125, 126, 1, 0, 0, 0, 126, 130, 1, 0, 0, 0, 127, 128, 5, 114, 0, 0,
		128, 131, 5, 116, 0, 0, 129, 131, 5, 116, 0, 0, 130, 127, 1, 0, 0, 0, 130,
		129, 1, 0, 0, 0, 130, 131, 1, 0, 0, 0, 131, 140, 1, 0, 0, 0, 132, 138,
		5, 42, 0, 0, 133, 139, 3, 52, 26, 0, 134, 135, 5, 1133, 0, 0, 135, 136,
		3, 70, 35, 0, 136, 137, 5, 1134, 0, 0, 137, 139, 1, 0, 0, 0, 138, 133,
		1, 0, 0, 0, 138, 134, 1, 0, 0, 0, 139, 141, 1, 0, 0, 0, 140, 132, 1, 0,
		0, 0, 140, 141, 1, 0, 0, 0, 141, 143, 1, 0, 0, 0, 142, 144, 5, 342, 0,
		0, 143, 142, 1, 0, 0, 0, 143, 144, 1, 0, 0, 0, 144, 146, 1, 0, 0, 0, 145,
		147, 5, 181, 0, 0, 146, 145, 1, 0, 0, 0, 146, 147, 1, 0, 0, 0, 147, 160,
		1, 0, 0, 0, 148, 150, 3, 10, 5, 0, 149, 148, 1, 0, 0, 0, 149, 150, 1, 0,
		0, 0, 150, 152, 1, 0, 0, 0, 151, 153, 3, 8, 4, 0, 152, 151, 1, 0, 0, 0,
		152, 153, 1, 0, 0, 0, 153, 161, 1, 0, 0, 0, 154, 156, 3, 8, 4, 0, 155,
		154, 1, 0, 0, 0, 155, 156, 1, 0, 0, 0, 156, 158, 1, 0, 0, 0, 157, 159,
		3, 10, 5, 0, 158, 157, 1, 0, 0, 0, 158, 159, 1, 0, 0, 0, 159, 161, 1, 0,
		0, 0, 160, 149, 1, 0, 0, 0, 160, 155, 1, 0, 0, 0, 161, 7, 1, 0, 0, 0, 162,
		163, 5, 368, 0, 0, 163, 164, 5, 1141, 0, 0, 164, 165, 3, 54, 27, 0, 165,
		166, 5, 1141, 0, 0, 166, 9, 1, 0, 0, 0, 167, 169, 5, 130, 0, 0, 168, 167,
		1, 0, 0, 0, 168, 169, 1, 0, 0, 0, 169, 170, 1, 0, 0, 0, 170, 171, 5, 91,
		0, 0, 171, 11, 1, 0, 0, 0, 172, 173, 5, 1133, 0, 0, 173, 174, 5, 1155,
		0, 0, 174, 175, 5, 1134, 0, 0, 175, 13, 1, 0, 0, 0, 176, 177, 7, 0, 0,
		0, 177, 15, 1, 0, 0, 0, 178, 180, 3, 42, 21, 0, 179, 181, 3, 66, 33, 0,
		180, 179, 1, 0, 0, 0, 180, 181, 1, 0, 0, 0, 181, 183, 1, 0, 0, 0, 182,
		178, 1, 0, 0, 0, 182, 183, 1, 0, 0, 0, 183, 185, 1, 0, 0, 0, 184, 186,
		7, 1, 0, 0, 185, 184, 1, 0, 0, 0, 185, 186, 1, 0, 0, 0, 186, 17, 1, 0,
		0, 0, 187, 188, 5, 187, 0, 0, 188, 189, 7, 2, 0, 0, 189, 19, 1, 0, 0, 0,
		190, 191, 5, 467, 0, 0, 191, 192, 5, 1124, 0, 0, 192, 210, 3, 64, 32, 0,
		193, 210, 3, 18, 9, 0, 194, 195, 5, 192, 0, 0, 195, 196, 5, 547, 0, 0,
		196, 210, 3, 58, 29, 0, 197, 198, 5, 368, 0, 0, 198, 199, 5, 1141, 0, 0,
		199, 200, 3, 54, 27, 0, 200, 201, 5, 1141, 0, 0, 201, 210, 1, 0, 0, 0,
		202, 210, 7, 3, 0, 0, 203, 204, 5, 875, 0, 0, 204, 205, 5, 1124, 0, 0,
		205, 210, 3, 54, 27, 0, 206, 207, 5, 1000, 0, 0, 207, 208, 5, 1124, 0,
		0, 208, 210, 3, 54, 27, 0, 209, 190, 1, 0, 0, 0, 209, 193, 1, 0, 0, 0,
		209, 194, 1, 0, 0, 0, 209, 197, 1, 0, 0, 0, 209, 202, 1, 0, 0, 0, 209,
		203, 1, 0, 0, 0, 209, 206, 1, 0, 0, 0, 210, 21, 1, 0, 0, 0, 211, 213, 5,
		30, 0, 0, 212, 214, 3, 50, 25, 0, 213, 212, 1, 0, 0, 0, 213, 214, 1, 0,
		0, 0, 214, 216, 1, 0, 0, 0, 215, 211, 1, 0, 0, 0, 215, 216, 1, 0, 0, 0,
		216, 217, 1, 0, 0, 0, 217, 218, 5, 26, 0, 0, 218, 219, 5, 1133, 0, 0, 219,
		220, 3, 70, 35, 0, 220, 223, 5, 1134, 0, 0, 221, 222, 5, 114, 0, 0, 222,
		224, 5, 57, 0, 0, 223, 221, 1, 0, 0, 0, 223, 224, 1, 0, 0, 0, 224, 23,
		1, 0, 0, 0, 225, 226, 5, 136, 0, 0, 226, 227, 3, 40, 20, 0, 227, 228, 5,
		1133, 0, 0, 228, 233, 3, 16, 8, 0, 229, 230, 5, 1135, 0, 0, 230, 232, 3,
		16, 8, 0, 231, 229, 1, 0, 0, 0, 232, 235, 1, 0, 0, 0, 233, 231, 1, 0, 0,
		0, 233, 234, 1, 0, 0, 0, 234, 236, 1, 0, 0, 0, 235, 233, 1, 0, 0, 0, 236,
		243, 5, 1134, 0, 0, 237, 238, 5, 109, 0, 0, 238, 244, 5, 436, 0, 0, 239,
		240, 5, 109, 0, 0, 240, 244, 5, 548, 0, 0, 241, 242, 5, 109, 0, 0, 242,
		244, 5, 613, 0, 0, 243, 237, 1, 0, 0, 0, 243, 239, 1, 0, 0, 0, 243, 241,
		1, 0, 0, 0, 243, 244, 1, 0, 0, 0, 244, 248, 1, 0, 0, 0, 245, 246, 5, 118,
		0, 0, 246, 247, 5, 44, 0, 0, 247, 249, 3, 26, 13, 0, 248, 245, 1, 0, 0,
		0, 248, 249, 1, 0, 0, 0, 249, 253, 1, 0, 0, 0, 250, 251, 5, 118, 0, 0,
		251, 252, 5, 184, 0, 0, 252, 254, 3, 26, 13, 0, 253, 250, 1, 0, 0, 0, 253,
		254, 1, 0, 0, 0, 254, 25, 1, 0, 0, 0, 255, 264, 5, 144, 0, 0, 256, 264,
		5, 21, 0, 0, 257, 258, 5, 153, 0, 0, 258, 264, 5, 116, 0, 0, 259, 260,
		5, 521, 0, 0, 260, 264, 5, 333, 0, 0, 261, 262, 5, 153, 0, 0, 262, 264,
		5, 42, 0, 0, 263, 255, 1, 0, 0, 0, 263, 256, 1, 0, 0, 0, 263, 257, 1, 0,
		0, 0, 263, 259, 1, 0, 0, 0, 263, 261, 1, 0, 0, 0, 264, 27, 1, 0, 0, 0,
		265, 270, 3, 30, 15, 0, 266, 267, 5, 1135, 0, 0, 267, 269, 3, 30, 15, 0,
		268, 266, 1, 0, 0, 0, 269, 272, 1, 0, 0, 0, 270, 268, 1, 0, 0, 0, 270,
		271, 1, 0, 0, 0, 271, 29, 1, 0, 0, 0, 272, 270, 1, 0, 0, 0, 273, 274, 5,
		341, 0, 0, 274, 275, 5, 1124, 0, 0, 275, 387, 3, 64, 32, 0, 276, 277, 5,
		342, 0, 0, 277, 278, 5, 1124, 0, 0, 278, 387, 3, 64, 32, 0, 279, 280, 5,
		343, 0, 0, 280, 281, 5, 1124, 0, 0, 281, 387, 3, 64, 32, 0, 282, 284, 5,
		42, 0, 0, 283, 282, 1, 0, 0, 0, 283, 284, 1, 0, 0, 0, 284, 285, 1, 0, 0,
		0, 285, 286, 5, 25, 0, 0, 286, 287, 5, 153, 0, 0, 287, 288, 5, 1124, 0,
		0, 288, 387, 3, 62, 31, 0, 289, 290, 5, 356, 0, 0, 290, 291, 5, 1124, 0,
		0, 291, 387, 7, 4, 0, 0, 292, 294, 5, 42, 0, 0, 293, 292, 1, 0, 0, 0, 293,
		294, 1, 0, 0, 0, 294, 295, 1, 0, 0, 0, 295, 296, 5, 27, 0, 0, 296, 297,
		5, 1124, 0, 0, 297, 387, 3, 56, 28, 0, 298, 300, 5, 368, 0, 0, 299, 301,
		5, 1124, 0, 0, 300, 299, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 302, 1,
		0, 0, 0, 302, 303, 5, 1141, 0, 0, 303, 304, 3, 54, 27, 0, 304, 305, 5,
		1141, 0, 0, 305, 387, 1, 0, 0, 0, 306, 307, 5, 376, 0, 0, 307, 308, 5,
		1124, 0, 0, 308, 309, 5, 1141, 0, 0, 309, 310, 3, 60, 30, 0, 310, 311,
		5, 1141, 0, 0, 311, 387, 1, 0, 0, 0, 312, 313, 7, 5, 0, 0, 313, 314, 5,
		395, 0, 0, 314, 315, 5, 1124, 0, 0, 315, 316, 5, 1141, 0, 0, 316, 317,
		3, 68, 34, 0, 317, 318, 5, 1141, 0, 0, 318, 387, 1, 0, 0, 0, 319, 320,
		5, 393, 0, 0, 320, 321, 5, 1124, 0, 0, 321, 387, 7, 4, 0, 0, 322, 323,
		5, 409, 0, 0, 323, 324, 5, 1124, 0, 0, 324, 387, 3, 48, 24, 0, 325, 326,
		5, 875, 0, 0, 326, 327, 5, 1124, 0, 0, 327, 328, 5, 1141, 0, 0, 328, 329,
		3, 54, 27, 0, 329, 330, 5, 1141, 0, 0, 330, 387, 1, 0, 0, 0, 331, 332,
		5, 455, 0, 0, 332, 333, 5, 1124, 0, 0, 333, 387, 7, 6, 0, 0, 334, 335,
		5, 467, 0, 0, 335, 336, 5, 1124, 0, 0, 336, 387, 3, 64, 32, 0, 337, 338,
		5, 500, 0, 0, 338, 339, 5, 1124, 0, 0, 339, 387, 3, 64, 32, 0, 340, 341,
		5, 510, 0, 0, 341, 342, 5, 1124, 0, 0, 342, 387, 3, 64, 32, 0, 343, 344,
		5, 543, 0, 0, 344, 345, 5, 1124, 0, 0, 345, 387, 7, 7, 0, 0, 346, 347,
		5, 551, 0, 0, 347, 348, 5, 1124, 0, 0, 348, 349, 5, 1141, 0, 0, 349, 350,
		3, 54, 27, 0, 350, 351, 5, 1141, 0, 0, 351, 387, 1, 0, 0, 0, 352, 353,
		5, 602, 0, 0, 353, 354, 5, 1124, 0, 0, 354, 387, 7, 8, 0, 0, 355, 356,
		5, 629, 0, 0, 356, 387, 5, 653, 0, 0, 357, 358, 5, 1000, 0, 0, 358, 359,
		5, 1124, 0, 0, 359, 360, 5, 1141, 0, 0, 360, 361, 3, 54, 27, 0, 361, 362,
		5, 1141, 0, 0, 362, 387, 1, 0, 0, 0, 363, 364, 5, 631, 0, 0, 364, 365,
		5, 1124, 0, 0, 365, 387, 7, 7, 0, 0, 366, 367, 5, 632, 0, 0, 367, 368,
		5, 1124, 0, 0, 368, 387, 7, 7, 0, 0, 369, 370, 5, 633, 0, 0, 370, 371,
		5, 1124, 0, 0, 371, 387, 3, 64, 32, 0, 372, 387, 3, 38, 19, 0, 373, 374,
		5, 180, 0, 0, 374, 375, 5, 1124, 0, 0, 375, 376, 5, 1133, 0, 0, 376, 381,
		3, 40, 20, 0, 377, 378, 5, 1135, 0, 0, 378, 380, 3, 40, 20, 0, 379, 377,
		1, 0, 0, 0, 380, 383, 1, 0, 0, 0, 381, 379, 1, 0, 0, 0, 381, 382, 1, 0,
		0, 0, 382, 384, 1, 0, 0, 0, 383, 381, 1, 0, 0, 0, 384, 385, 5, 1134, 0,
		0, 385, 387, 1, 0, 0, 0, 386, 273, 1, 0, 0, 0, 386, 276, 1, 0, 0, 0, 386,
		279, 1, 0, 0, 0, 386, 283, 1, 0, 0, 0, 386, 289, 1, 0, 0, 0, 386, 293,
		1, 0, 0, 0, 386, 298, 1, 0, 0, 0, 386, 306, 1, 0, 0, 0, 386, 312, 1, 0,
		0, 0, 386, 319, 1, 0, 0, 0, 386, 322, 1, 0, 0, 0, 386, 325, 1, 0, 0, 0,
		386, 331, 1, 0, 0, 0, 386, 334, 1, 0, 0, 0, 386, 337, 1, 0, 0, 0, 386,
		340, 1, 0, 0, 0, 386, 343, 1, 0, 0, 0, 386, 346, 1, 0, 0, 0, 386, 352,
		1, 0, 0, 0, 386, 355, 1, 0, 0, 0, 386, 357, 1, 0, 0, 0, 386, 363, 1, 0,
		0, 0, 386, 366, 1, 0, 0, 0, 386, 369, 1, 0, 0, 0, 386, 372, 1, 0, 0, 0,
		386, 373, 1, 0, 0, 0, 387, 31, 1, 0, 0, 0, 388, 389, 5, 129, 0, 0, 389,
		435, 5, 19, 0, 0, 390, 392, 5, 100, 0, 0, 391, 390, 1, 0, 0, 0, 391, 392,
		1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 394, 5, 443, 0, 0, 394, 395, 5,
		1133, 0, 0, 395, 396, 3, 70, 35, 0, 396, 397, 5, 1134, 0, 0, 397, 436,
		1, 0, 0, 0, 398, 400, 5, 100, 0, 0, 399, 398, 1, 0, 0, 0, 399, 400, 1,
		0, 0, 0, 400, 401, 1, 0, 0, 0, 401, 405, 5, 91, 0, 0, 402, 403, 5, 336,
		0, 0, 403, 404, 5, 1124, 0, 0, 404, 406, 7, 9, 0, 0, 405, 402, 1, 0, 0,
		0, 405, 406, 1, 0, 0, 0, 406, 407, 1, 0, 0, 0, 407, 408, 5, 1133, 0, 0,
		408, 409, 3, 86, 43, 0, 409, 410, 5, 1134, 0, 0, 410, 436, 1, 0, 0, 0,
		411, 416, 5, 133, 0, 0, 412, 413, 5, 1133, 0, 0, 413, 414, 3, 70, 35, 0,
		414, 415, 5, 1134, 0, 0, 415, 417, 1, 0, 0, 0, 416, 412, 1, 0, 0, 0, 416,
		417, 1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 419, 5, 365, 0, 0, 419, 420,
		5, 1133, 0, 0, 420, 421, 3, 86, 43, 0, 421, 422, 5, 1134, 0, 0, 422, 436,
		1, 0, 0, 0, 423, 428, 5, 473, 0, 0, 424, 425, 5, 1133, 0, 0, 425, 426,
		3, 70, 35, 0, 426, 427, 5, 1134, 0, 0, 427, 429, 1, 0, 0, 0, 428, 424,
		1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 430, 1, 0, 0, 0, 430, 431, 5, 365,
		0, 0, 431, 432, 5, 1133, 0, 0, 432, 433, 3, 86, 43, 0, 433, 434, 5, 1134,
		0, 0, 434, 436, 1, 0, 0, 0, 435, 391, 1, 0, 0, 0, 435, 399, 1, 0, 0, 0,
		435, 411, 1, 0, 0, 0, 435, 423, 1, 0, 0, 0, 436, 439, 1, 0, 0, 0, 437,
		438, 5, 550, 0, 0, 438, 440, 3, 72, 36, 0, 439, 437, 1, 0, 0, 0, 439, 440,
		1, 0, 0, 0, 440, 470, 1, 0, 0, 0, 441, 442, 5, 641, 0, 0, 442, 464, 5,
		19, 0, 0, 443, 445, 5, 100, 0, 0, 444, 443, 1, 0, 0, 0, 444, 445, 1, 0,
		0, 0, 445, 446, 1, 0, 0, 0, 446, 447, 5, 443, 0, 0, 447, 448, 5, 1133,
		0, 0, 448, 449, 3, 70, 35, 0, 449, 450, 5, 1134, 0, 0, 450, 465, 1, 0,
		0, 0, 451, 453, 5, 100, 0, 0, 452, 451, 1, 0, 0, 0, 452, 453, 1, 0, 0,
		0, 453, 454, 1, 0, 0, 0, 454, 458, 5, 91, 0, 0, 455, 456, 5, 336, 0, 0,
		456, 457, 5, 1124, 0, 0, 457, 459, 7, 9, 0, 0, 458, 455, 1, 0, 0, 0, 458,
		459, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 461, 5, 1133, 0, 0, 461, 462,
		3, 86, 43, 0, 462, 463, 5, 1134, 0, 0, 463, 465, 1, 0, 0, 0, 464, 444,
		1, 0, 0, 0, 464, 452, 1, 0, 0, 0, 465, 468, 1, 0, 0, 0, 466, 467, 5, 642,
		0, 0, 467, 469, 3, 72, 36, 0, 468, 466, 1, 0, 0, 0, 468, 469, 1, 0, 0,
		0, 469, 471, 1, 0, 0, 0, 470, 441, 1, 0, 0, 0, 470, 471, 1, 0, 0, 0, 471,
		483, 1, 0, 0, 0, 472, 473, 5, 1133, 0, 0, 473, 478, 3, 34, 17, 0, 474,
		475, 5, 1135, 0, 0, 475, 477, 3, 34, 17, 0, 476, 474, 1, 0, 0, 0, 477,
		480, 1, 0, 0, 0, 478, 476, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 481,
		1, 0, 0, 0, 480, 478, 1, 0, 0, 0, 481, 482, 5, 1134, 0, 0, 482, 484, 1,
		0, 0, 0, 483, 472, 1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 33, 1, 0, 0,
		0, 485, 486, 5, 129, 0, 0, 486, 505, 3, 78, 39, 0, 487, 488, 5, 188, 0,
		0, 488, 489, 5, 471, 0, 0, 489, 498, 5, 651, 0, 0, 490, 491, 5, 1133, 0,
		0, 491, 492, 3, 70, 35, 0, 492, 493, 5, 1134, 0, 0, 493, 496, 1, 0, 0,
		0, 494, 496, 3, 88, 44, 0, 495, 490, 1, 0, 0, 0, 495, 494, 1, 0, 0, 0,
		496, 499, 1, 0, 0, 0, 497, 499, 5, 110, 0, 0, 498, 495, 1, 0, 0, 0, 498,
		497, 1, 0, 0, 0, 499, 506, 1, 0, 0, 0, 500, 501, 5, 80, 0, 0, 501, 502,
		5, 1133, 0, 0, 502, 503, 3, 88, 44, 0, 503, 504, 5, 1134, 0, 0, 504, 506,
		1, 0, 0, 0, 505, 487, 1, 0, 0, 0, 505, 500, 1, 0, 0, 0, 505, 506, 1, 0,
		0, 0, 506, 513, 1, 0, 0, 0, 507, 509, 5, 636, 0, 0, 508, 507, 1, 0, 0,
		0, 508, 509, 1, 0, 0, 0, 509, 510, 1, 0, 0, 0, 510, 511, 5, 409, 0, 0,
		511, 512, 5, 1124, 0, 0, 512, 514, 3, 48, 24, 0, 513, 508, 1, 0, 0, 0,
		513, 514, 1, 0, 0, 0, 514, 521, 1, 0, 0, 0, 515, 516, 5, 368, 0, 0, 516,
		517, 5, 1124, 0, 0, 517, 518, 5, 1141, 0, 0, 518, 519, 3, 54, 27, 0, 519,
		520, 5, 1141, 0, 0, 520, 522, 1, 0, 0, 0, 521, 515, 1, 0, 0, 0, 521, 522,
		1, 0, 0, 0, 522, 530, 1, 0, 0, 0, 523, 524, 5, 388, 0, 0, 524, 525, 5,
		395, 0, 0, 525, 526, 5, 1124, 0, 0, 526, 527, 5, 1141, 0, 0, 527, 528,
		3, 82, 41, 0, 528, 529, 5, 1141, 0, 0, 529, 531, 1, 0, 0, 0, 530, 523,
		1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 539, 1, 0, 0, 0, 532, 533, 5, 81,
		0, 0, 533, 534, 5, 395, 0, 0, 534, 535, 5, 1124, 0, 0, 535, 536, 5, 1141,
		0, 0, 536, 537, 3, 84, 42, 0, 537, 538, 5, 1141, 0, 0, 538, 540, 1, 0,
		0, 0, 539, 532, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 544, 1, 0, 0, 0,
		541, 542, 5, 500, 0, 0, 542, 543, 5, 1124, 0, 0, 543, 545, 3, 74, 37, 0,
		544, 541, 1, 0, 0, 0, 544, 545, 1, 0, 0, 0, 545, 549, 1, 0, 0, 0, 546,
		547, 5, 510, 0, 0, 547, 548, 5, 1124, 0, 0, 548, 550, 3, 76, 38, 0, 549,
		546, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 554, 1, 0, 0, 0, 551, 552,
		5, 647, 0, 0, 552, 553, 5, 1124, 0, 0, 553, 555, 3, 44, 22, 0, 554, 551,
		1, 0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 567, 1, 0, 0, 0, 556, 557, 5, 1133,
		0, 0, 557, 562, 3, 36, 18, 0, 558, 559, 5, 1135, 0, 0, 559, 561, 3, 36,
		18, 0, 560, 558, 1, 0, 0, 0, 561, 564, 1, 0, 0, 0, 562, 560, 1, 0, 0, 0,
		562, 563, 1, 0, 0, 0, 563, 565, 1, 0, 0, 0, 564, 562, 1, 0, 0, 0, 565,
		566, 5, 1134, 0, 0, 566, 568, 1, 0, 0, 0, 567, 556, 1, 0, 0, 0, 567, 568,
		1, 0, 0, 0, 568, 35, 1, 0, 0, 0, 569, 570, 5, 641, 0, 0, 570, 577, 3, 80,
		40, 0, 571, 573, 5, 636, 0, 0, 572, 571, 1, 0, 0, 0, 572, 573, 1, 0, 0,
		0, 573, 574, 1, 0, 0, 0, 574, 575, 5, 409, 0, 0, 575, 576, 5, 1124, 0,
		0, 576, 578, 3, 48, 24, 0, 577, 572, 1, 0, 0, 0, 577, 578, 1, 0, 0, 0,
		578, 585, 1, 0, 0, 0, 579, 580, 5, 368, 0, 0, 580, 581, 5, 1124, 0, 0,
		581, 582, 5, 1141, 0, 0, 582, 583, 3, 54, 27, 0, 583, 584, 5, 1141, 0,
		0, 584, 586, 1, 0, 0, 0, 585, 579, 1, 0, 0, 0, 585, 586, 1, 0, 0, 0, 586,
		594, 1, 0, 0, 0, 587, 588, 5, 388, 0, 0, 588, 589, 5, 395, 0, 0, 589, 590,
		5, 1124, 0, 0, 590, 591, 5, 1141, 0, 0, 591, 592, 3, 82, 41, 0, 592, 593,
		5, 1141, 0, 0, 593, 595, 1, 0, 0, 0, 594, 587, 1, 0, 0, 0, 594, 595, 1,
		0, 0, 0, 595, 603, 1, 0, 0, 0, 596, 597, 5, 81, 0, 0, 597, 598, 5, 395,
		0, 0, 598, 599, 5, 1124, 0, 0, 599, 600, 5, 1141, 0, 0, 600, 601, 3, 84,
		42, 0, 601, 602, 5, 1141, 0, 0, 602, 604, 1, 0, 0, 0, 603, 596, 1, 0, 0,
		0, 603, 604, 1, 0, 0, 0, 604, 608, 1, 0, 0, 0, 605, 606, 5, 500, 0, 0,
		606, 607, 5, 1124, 0, 0, 607, 609, 3, 74, 37, 0, 608, 605, 1, 0, 0, 0,
		608, 609, 1, 0, 0, 0, 609, 613, 1, 0, 0, 0, 610, 611, 5, 510, 0, 0, 611,
		612, 5, 1124, 0, 0, 612, 614, 3, 76, 38, 0, 613, 610, 1, 0, 0, 0, 613,
		614, 1, 0, 0, 0, 614, 618, 1, 0, 0, 0, 615, 616, 5, 647, 0, 0, 616, 617,
		5, 1124, 0, 0, 617, 619, 3, 44, 22, 0, 618, 615, 1, 0, 0, 0, 618, 619,
		1, 0, 0, 0, 619, 37, 1, 0, 0, 0, 620, 621, 5, 647, 0, 0, 621, 622, 3, 44,
		22, 0, 622, 623, 5, 636, 0, 0, 623, 624, 5, 398, 0, 0, 624, 632, 1, 0,
		0, 0, 625, 626, 5, 647, 0, 0, 626, 628, 3, 44, 22, 0, 627, 625, 1, 0, 0,
		0, 627, 628, 1, 0, 0, 0, 628, 629, 1, 0, 0, 0, 629, 630, 5, 636, 0, 0,
		630, 632, 5, 792, 0, 0, 631, 620, 1, 0, 0, 0, 631, 627, 1, 0, 0, 0, 632,
		39, 1, 0, 0, 0, 633, 634, 5, 1157, 0, 0, 634, 41, 1, 0, 0, 0, 635, 636,
		5, 1157, 0, 0, 636, 43, 1, 0, 0, 0, 637, 638, 5, 1157, 0, 0, 638, 45, 1,
		0, 0, 0, 639, 640, 5, 1157, 0, 0, 640, 47, 1, 0, 0, 0, 641, 642, 7, 10,
		0, 0, 642, 49, 1, 0, 0, 0, 643, 644, 5, 1157, 0, 0, 644, 51, 1, 0, 0, 0,
		645, 646, 5, 1157, 0, 0, 646, 53, 1, 0, 0, 0, 647, 648, 5, 1157, 0, 0,
		648, 55, 1, 0, 0, 0, 649, 650, 5, 1157, 0, 0, 650, 57, 1, 0, 0, 0, 651,
		652, 5, 1157, 0, 0, 652, 59, 1, 0, 0, 0, 653, 654, 5, 1157, 0, 0, 654,
		61, 1, 0, 0, 0, 655, 656, 5, 1157, 0, 0, 656, 63, 1, 0, 0, 0, 657, 658,
		5, 1157, 0, 0, 658, 65, 1, 0, 0, 0, 659, 660, 5, 1149, 0, 0, 660, 67, 1,
		0, 0, 0, 661, 662, 5, 1157, 0, 0, 662, 69, 1, 0, 0, 0, 663, 664, 5, 1157,
		0, 0, 664, 71, 1, 0, 0, 0, 665, 666, 5, 1155, 0, 0, 666, 73, 1, 0, 0, 0,
		667, 668, 5, 1155, 0, 0, 668, 75, 1, 0, 0, 0, 669, 670, 5, 1155, 0, 0,
		670, 77, 1, 0, 0, 0, 671, 672, 5, 1157, 0, 0, 672, 79, 1, 0, 0, 0, 673,
		674, 5, 1157, 0, 0, 674, 81, 1, 0, 0, 0, 675, 676, 5, 1157, 0, 0, 676,
		83, 1, 0, 0, 0, 677, 678, 5, 1157, 0, 0, 678, 85, 1, 0, 0, 0, 679, 680,
		3, 42, 21, 0, 680, 687, 3, 6, 3, 0, 681, 682, 5, 1135, 0, 0, 682, 683,
		3, 42, 21, 0, 683, 684, 3, 6, 3, 0, 684, 686, 1, 0, 0, 0, 685, 681, 1,
		0, 0, 0, 686, 689, 1, 0, 0, 0, 687, 685, 1, 0, 0, 0, 687, 688, 1, 0, 0,
		0, 688, 87, 1, 0, 0, 0, 689, 687, 1, 0, 0, 0, 690, 695, 5, 1157, 0, 0,
		691, 692, 5, 1135, 0, 0, 692, 694, 5, 1157, 0, 0, 693, 691, 1, 0, 0, 0,
		694, 697, 1, 0, 0, 0, 695, 693, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696,
		89, 1, 0, 0, 0, 697, 695, 1, 0, 0, 0, 75, 95, 101, 110, 115, 118, 125,
		130, 138, 140, 143, 146, 149, 152, 155, 158, 160, 168, 180, 182, 185, 209,
		213, 215, 223, 233, 243, 248, 253, 263, 270, 283, 293, 300, 381, 386, 391,
		399, 405, 416, 428, 435, 439, 444, 452, 458, 464, 468, 470, 478, 483, 495,
		498, 505, 508, 513, 521, 530, 539, 544, 549, 554, 562, 567, 572, 577, 585,
		594, 603, 608, 613, 618, 627, 631, 687, 695,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// CreateParserInit initializes any static state used to implement CreateParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCreateParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CreateParserInit() {
	staticData := &CreateParserParserStaticData
	staticData.once.Do(createparserParserInit)
}

// NewCreateParser produces a new parser instance for the optional input antlr.TokenStream.
func NewCreateParser(input antlr.TokenStream) *CreateParser {
	CreateParserInit()
	this := new(CreateParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &CreateParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "CreateParser.g4"

	return this
}

// CreateParser tokens.
const (
	CreateParserEOF                               = antlr.TokenEOF
	CreateParserSPACE                             = 1
	CreateParserSPEC_MYSQL_COMMENT                = 2
	CreateParserCOMMENT_INPUT                     = 3
	CreateParserLINE_COMMENT                      = 4
	CreateParserADD                               = 5
	CreateParserALL                               = 6
	CreateParserALTER                             = 7
	CreateParserALWAYS                            = 8
	CreateParserANALYZE                           = 9
	CreateParserAND                               = 10
	CreateParserARRAY                             = 11
	CreateParserAS                                = 12
	CreateParserASC                               = 13
	CreateParserATTRIBUTE                         = 14
	CreateParserBEFORE                            = 15
	CreateParserBETWEEN                           = 16
	CreateParserBOTH                              = 17
	CreateParserBUCKETS                           = 18
	CreateParserBY                                = 19
	CreateParserCALL                              = 20
	CreateParserCASCADE                           = 21
	CreateParserCASE                              = 22
	CreateParserCAST                              = 23
	CreateParserCHANGE                            = 24
	CreateParserCHARACTER                         = 25
	CreateParserCHECK                             = 26
	CreateParserCOLLATE                           = 27
	CreateParserCOLUMN                            = 28
	CreateParserCONDITION                         = 29
	CreateParserCONSTRAINT                        = 30
	CreateParserCONTINUE                          = 31
	CreateParserCONVERT                           = 32
	CreateParserCREATE                            = 33
	CreateParserCROSS                             = 34
	CreateParserCURRENT                           = 35
	CreateParserCURRENT_ROLE                      = 36
	CreateParserCURRENT_USER                      = 37
	CreateParserCURSOR                            = 38
	CreateParserDATABASE                          = 39
	CreateParserDATABASES                         = 40
	CreateParserDECLARE                           = 41
	CreateParserDEFAULT                           = 42
	CreateParserDELAYED                           = 43
	CreateParserDELETE                            = 44
	CreateParserDESC                              = 45
	CreateParserDESCRIBE                          = 46
	CreateParserDETERMINISTIC                     = 47
	CreateParserDIAGNOSTICS                       = 48
	CreateParserDISTINCT                          = 49
	CreateParserDISTINCTROW                       = 50
	CreateParserDROP                              = 51
	CreateParserEACH                              = 52
	CreateParserELSE                              = 53
	CreateParserELSEIF                            = 54
	CreateParserEMPTY                             = 55
	CreateParserENCLOSED                          = 56
	CreateParserENFORCED                          = 57
	CreateParserESCAPED                           = 58
	CreateParserEXCEPT                            = 59
	CreateParserEXISTS                            = 60
	CreateParserEXIT                              = 61
	CreateParserEXPLAIN                           = 62
	CreateParserFALSE                             = 63
	CreateParserFETCH                             = 64
	CreateParserFOR                               = 65
	CreateParserFORCE                             = 66
	CreateParserFOREIGN                           = 67
	CreateParserFROM                              = 68
	CreateParserFULLTEXT                          = 69
	CreateParserGENERATED                         = 70
	CreateParserGET                               = 71
	CreateParserGRANT                             = 72
	CreateParserGROUP                             = 73
	CreateParserHAVING                            = 74
	CreateParserHIGH_PRIORITY                     = 75
	CreateParserHISTOGRAM                         = 76
	CreateParserIF                                = 77
	CreateParserIGNORE                            = 78
	CreateParserIGNORED                           = 79
	CreateParserIN                                = 80
	CreateParserINDEX                             = 81
	CreateParserINFILE                            = 82
	CreateParserINNER                             = 83
	CreateParserINOUT                             = 84
	CreateParserINSERT                            = 85
	CreateParserINTERVAL                          = 86
	CreateParserINTO                              = 87
	CreateParserIS                                = 88
	CreateParserITERATE                           = 89
	CreateParserJOIN                              = 90
	CreateParserKEY                               = 91
	CreateParserKEYS                              = 92
	CreateParserKILL                              = 93
	CreateParserLATERAL                           = 94
	CreateParserLEADING                           = 95
	CreateParserLEAVE                             = 96
	CreateParserLEFT                              = 97
	CreateParserLIKE                              = 98
	CreateParserLIMIT                             = 99
	CreateParserLINEAR                            = 100
	CreateParserLINES                             = 101
	CreateParserLOAD                              = 102
	CreateParserLOCK                              = 103
	CreateParserLOCKED                            = 104
	CreateParserLOOP                              = 105
	CreateParserLOW_PRIORITY                      = 106
	CreateParserMASTER_BIND                       = 107
	CreateParserMASTER_SSL_VERIFY_SERVER_CERT     = 108
	CreateParserMATCH                             = 109
	CreateParserMAXVALUE                          = 110
	CreateParserMINVALUE                          = 111
	CreateParserMODIFIES                          = 112
	CreateParserNATURAL                           = 113
	CreateParserNOT                               = 114
	CreateParserNO_WRITE_TO_BINLOG                = 115
	CreateParserNULL_LITERAL                      = 116
	CreateParserNUMBER                            = 117
	CreateParserON                                = 118
	CreateParserOPTIMIZE                          = 119
	CreateParserOPTION                            = 120
	CreateParserOPTIONAL                          = 121
	CreateParserOPTIONALLY                        = 122
	CreateParserOR                                = 123
	CreateParserORDER                             = 124
	CreateParserOUT                               = 125
	CreateParserOUTER                             = 126
	CreateParserOUTFILE                           = 127
	CreateParserOVER                              = 128
	CreateParserPARTITION                         = 129
	CreateParserPRIMARY                           = 130
	CreateParserPROCEDURE                         = 131
	CreateParserPURGE                             = 132
	CreateParserRANGE                             = 133
	CreateParserREAD                              = 134
	CreateParserREADS                             = 135
	CreateParserREFERENCES                        = 136
	CreateParserREGEXP                            = 137
	CreateParserRELEASE                           = 138
	CreateParserRENAME                            = 139
	CreateParserREPEAT                            = 140
	CreateParserREPLACE                           = 141
	CreateParserREQUIRE                           = 142
	CreateParserRESIGNAL                          = 143
	CreateParserRESTRICT                          = 144
	CreateParserRETAIN                            = 145
	CreateParserRETURN                            = 146
	CreateParserREVOKE                            = 147
	CreateParserRIGHT                             = 148
	CreateParserRLIKE                             = 149
	CreateParserSCHEMA                            = 150
	CreateParserSCHEMAS                           = 151
	CreateParserSELECT                            = 152
	CreateParserSET                               = 153
	CreateParserSEPARATOR                         = 154
	CreateParserSHOW                              = 155
	CreateParserSIGNAL                            = 156
	CreateParserSKIP_                             = 157
	CreateParserSKIP_QUERY_REWRITE                = 158
	CreateParserSPATIAL                           = 159
	CreateParserSQL                               = 160
	CreateParserSQLEXCEPTION                      = 161
	CreateParserSQLSTATE                          = 162
	CreateParserSQLWARNING                        = 163
	CreateParserSQL_BIG_RESULT                    = 164
	CreateParserSQL_CALC_FOUND_ROWS               = 165
	CreateParserSQL_SMALL_RESULT                  = 166
	CreateParserSSL                               = 167
	CreateParserSTACKED                           = 168
	CreateParserSTARTING                          = 169
	CreateParserSTATEMENT                         = 170
	CreateParserSTRAIGHT_JOIN                     = 171
	CreateParserTABLE                             = 172
	CreateParserTERMINATED                        = 173
	CreateParserTHEN                              = 174
	CreateParserTO                                = 175
	CreateParserTRAILING                          = 176
	CreateParserTRIGGER                           = 177
	CreateParserTRUE                              = 178
	CreateParserUNDO                              = 179
	CreateParserUNION                             = 180
	CreateParserUNIQUE                            = 181
	CreateParserUNLOCK                            = 182
	CreateParserUNSIGNED                          = 183
	CreateParserUPDATE                            = 184
	CreateParserUSAGE                             = 185
	CreateParserUSE                               = 186
	CreateParserUSING                             = 187
	CreateParserVALUES                            = 188
	CreateParserWHEN                              = 189
	CreateParserWHERE                             = 190
	CreateParserWHILE                             = 191
	CreateParserWITH                              = 192
	CreateParserWRITE                             = 193
	CreateParserXOR                               = 194
	CreateParserZEROFILL                          = 195
	CreateParserTINYINT                           = 196
	CreateParserSMALLINT                          = 197
	CreateParserMEDIUMINT                         = 198
	CreateParserMIDDLEINT                         = 199
	CreateParserINT                               = 200
	CreateParserINT1                              = 201
	CreateParserINT2                              = 202
	CreateParserINT3                              = 203
	CreateParserINT4                              = 204
	CreateParserINT8                              = 205
	CreateParserINTEGER                           = 206
	CreateParserBIGINT                            = 207
	CreateParserREAL                              = 208
	CreateParserDOUBLE                            = 209
	CreateParserPRECISION                         = 210
	CreateParserFLOAT                             = 211
	CreateParserFLOAT4                            = 212
	CreateParserFLOAT8                            = 213
	CreateParserDECIMAL                           = 214
	CreateParserDEC                               = 215
	CreateParserNUMERIC                           = 216
	CreateParserDATE                              = 217
	CreateParserTIME                              = 218
	CreateParserTIMESTAMP                         = 219
	CreateParserDATETIME                          = 220
	CreateParserYEAR                              = 221
	CreateParserCHAR                              = 222
	CreateParserVARCHAR                           = 223
	CreateParserNVARCHAR                          = 224
	CreateParserNATIONAL                          = 225
	CreateParserBINARY                            = 226
	CreateParserVARBINARY                         = 227
	CreateParserTINYBLOB                          = 228
	CreateParserBLOB                              = 229
	CreateParserMEDIUMBLOB                        = 230
	CreateParserLONG                              = 231
	CreateParserLONGBLOB                          = 232
	CreateParserTINYTEXT                          = 233
	CreateParserTEXT                              = 234
	CreateParserMEDIUMTEXT                        = 235
	CreateParserLONGTEXT                          = 236
	CreateParserENUM                              = 237
	CreateParserVARYING                           = 238
	CreateParserSERIAL                            = 239
	CreateParserYEAR_MONTH                        = 240
	CreateParserDAY_HOUR                          = 241
	CreateParserDAY_MINUTE                        = 242
	CreateParserDAY_SECOND                        = 243
	CreateParserHOUR_MINUTE                       = 244
	CreateParserHOUR_SECOND                       = 245
	CreateParserMINUTE_SECOND                     = 246
	CreateParserSECOND_MICROSECOND                = 247
	CreateParserMINUTE_MICROSECOND                = 248
	CreateParserHOUR_MICROSECOND                  = 249
	CreateParserDAY_MICROSECOND                   = 250
	CreateParserJSON_ARRAY                        = 251
	CreateParserJSON_ARRAYAGG                     = 252
	CreateParserJSON_ARRAY_APPEND                 = 253
	CreateParserJSON_ARRAY_INSERT                 = 254
	CreateParserJSON_CONTAINS                     = 255
	CreateParserJSON_CONTAINS_PATH                = 256
	CreateParserJSON_DEPTH                        = 257
	CreateParserJSON_EXTRACT                      = 258
	CreateParserJSON_INSERT                       = 259
	CreateParserJSON_KEYS                         = 260
	CreateParserJSON_LENGTH                       = 261
	CreateParserJSON_MERGE                        = 262
	CreateParserJSON_MERGE_PATCH                  = 263
	CreateParserJSON_MERGE_PRESERVE               = 264
	CreateParserJSON_OBJECT                       = 265
	CreateParserJSON_OBJECTAGG                    = 266
	CreateParserJSON_OVERLAPS                     = 267
	CreateParserJSON_PRETTY                       = 268
	CreateParserJSON_QUOTE                        = 269
	CreateParserJSON_REMOVE                       = 270
	CreateParserJSON_REPLACE                      = 271
	CreateParserJSON_SCHEMA_VALID                 = 272
	CreateParserJSON_SCHEMA_VALIDATION_REPORT     = 273
	CreateParserJSON_SEARCH                       = 274
	CreateParserJSON_SET                          = 275
	CreateParserJSON_STORAGE_FREE                 = 276
	CreateParserJSON_STORAGE_SIZE                 = 277
	CreateParserJSON_TABLE                        = 278
	CreateParserJSON_TYPE                         = 279
	CreateParserJSON_UNQUOTE                      = 280
	CreateParserJSON_VALID                        = 281
	CreateParserJSON_VALUE                        = 282
	CreateParserNESTED                            = 283
	CreateParserORDINALITY                        = 284
	CreateParserPATH                              = 285
	CreateParserAVG                               = 286
	CreateParserBIT_AND                           = 287
	CreateParserBIT_OR                            = 288
	CreateParserBIT_XOR                           = 289
	CreateParserCOUNT                             = 290
	CreateParserCUME_DIST                         = 291
	CreateParserDENSE_RANK                        = 292
	CreateParserFIRST_VALUE                       = 293
	CreateParserGROUP_CONCAT                      = 294
	CreateParserLAG                               = 295
	CreateParserLAST_VALUE                        = 296
	CreateParserLEAD                              = 297
	CreateParserMAX                               = 298
	CreateParserMIN                               = 299
	CreateParserNTILE                             = 300
	CreateParserNTH_VALUE                         = 301
	CreateParserPERCENT_RANK                      = 302
	CreateParserRANK                              = 303
	CreateParserROW_NUMBER                        = 304
	CreateParserSTD                               = 305
	CreateParserSTDDEV                            = 306
	CreateParserSTDDEV_POP                        = 307
	CreateParserSTDDEV_SAMP                       = 308
	CreateParserSUM                               = 309
	CreateParserVAR_POP                           = 310
	CreateParserVAR_SAMP                          = 311
	CreateParserVARIANCE                          = 312
	CreateParserCURRENT_DATE                      = 313
	CreateParserCURRENT_TIME                      = 314
	CreateParserCURRENT_TIMESTAMP                 = 315
	CreateParserLOCALTIME                         = 316
	CreateParserCURDATE                           = 317
	CreateParserCURTIME                           = 318
	CreateParserDATE_ADD                          = 319
	CreateParserDATE_SUB                          = 320
	CreateParserEXTRACT                           = 321
	CreateParserLOCALTIMESTAMP                    = 322
	CreateParserNOW                               = 323
	CreateParserPOSITION                          = 324
	CreateParserSUBSTR                            = 325
	CreateParserSUBSTRING                         = 326
	CreateParserSYSDATE                           = 327
	CreateParserTRIM                              = 328
	CreateParserUTC_DATE                          = 329
	CreateParserUTC_TIME                          = 330
	CreateParserUTC_TIMESTAMP                     = 331
	CreateParserACCOUNT                           = 332
	CreateParserACTION                            = 333
	CreateParserAFTER                             = 334
	CreateParserAGGREGATE                         = 335
	CreateParserALGORITHM                         = 336
	CreateParserANY                               = 337
	CreateParserAT                                = 338
	CreateParserAUTHORS                           = 339
	CreateParserAUTOCOMMIT                        = 340
	CreateParserAUTOEXTEND_SIZE                   = 341
	CreateParserAUTO_INCREMENT                    = 342
	CreateParserAVG_ROW_LENGTH                    = 343
	CreateParserBEGIN                             = 344
	CreateParserBINLOG                            = 345
	CreateParserBIT                               = 346
	CreateParserBLOCK                             = 347
	CreateParserBOOL                              = 348
	CreateParserBOOLEAN                           = 349
	CreateParserBTREE                             = 350
	CreateParserCACHE                             = 351
	CreateParserCASCADED                          = 352
	CreateParserCHAIN                             = 353
	CreateParserCHANGED                           = 354
	CreateParserCHANNEL                           = 355
	CreateParserCHECKSUM                          = 356
	CreateParserPAGE_CHECKSUM                     = 357
	CreateParserCIPHER                            = 358
	CreateParserCLASS_ORIGIN                      = 359
	CreateParserCLIENT                            = 360
	CreateParserCLOSE                             = 361
	CreateParserCLUSTERING                        = 362
	CreateParserCOALESCE                          = 363
	CreateParserCODE                              = 364
	CreateParserCOLUMNS                           = 365
	CreateParserCOLUMN_FORMAT                     = 366
	CreateParserCOLUMN_NAME                       = 367
	CreateParserCOMMENT                           = 368
	CreateParserCOMMIT                            = 369
	CreateParserCOMPACT                           = 370
	CreateParserCOMPLETION                        = 371
	CreateParserCOMPRESSED                        = 372
	CreateParserCOMPRESSION                       = 373
	CreateParserCONCURRENT                        = 374
	CreateParserCONNECT                           = 375
	CreateParserCONNECTION                        = 376
	CreateParserCONSISTENT                        = 377
	CreateParserCONSTRAINT_CATALOG                = 378
	CreateParserCONSTRAINT_SCHEMA                 = 379
	CreateParserCONSTRAINT_NAME                   = 380
	CreateParserCONTAINS                          = 381
	CreateParserCONTEXT                           = 382
	CreateParserCONTRIBUTORS                      = 383
	CreateParserCOPY                              = 384
	CreateParserCPU                               = 385
	CreateParserCYCLE                             = 386
	CreateParserCURSOR_NAME                       = 387
	CreateParserDATA                              = 388
	CreateParserDATAFILE                          = 389
	CreateParserDEALLOCATE                        = 390
	CreateParserDEFAULT_AUTH                      = 391
	CreateParserDEFINER                           = 392
	CreateParserDELAY_KEY_WRITE                   = 393
	CreateParserDES_KEY_FILE                      = 394
	CreateParserDIRECTORY                         = 395
	CreateParserDISABLE                           = 396
	CreateParserDISCARD                           = 397
	CreateParserDISK                              = 398
	CreateParserDO                                = 399
	CreateParserDUMPFILE                          = 400
	CreateParserDUPLICATE                         = 401
	CreateParserDYNAMIC                           = 402
	CreateParserENABLE                            = 403
	CreateParserENCRYPTED                         = 404
	CreateParserENCRYPTION                        = 405
	CreateParserENCRYPTION_KEY_ID                 = 406
	CreateParserEND                               = 407
	CreateParserENDS                              = 408
	CreateParserENGINE                            = 409
	CreateParserENGINES                           = 410
	CreateParserERROR                             = 411
	CreateParserERRORS                            = 412
	CreateParserESCAPE                            = 413
	CreateParserEVEN                              = 414
	CreateParserEVENT                             = 415
	CreateParserEVENTS                            = 416
	CreateParserEVERY                             = 417
	CreateParserEXCHANGE                          = 418
	CreateParserEXCLUSIVE                         = 419
	CreateParserEXPIRE                            = 420
	CreateParserEXPORT                            = 421
	CreateParserEXTENDED                          = 422
	CreateParserEXTENT_SIZE                       = 423
	CreateParserFAILED_LOGIN_ATTEMPTS             = 424
	CreateParserFAST                              = 425
	CreateParserFAULTS                            = 426
	CreateParserFIELDS                            = 427
	CreateParserFILE_BLOCK_SIZE                   = 428
	CreateParserFILTER                            = 429
	CreateParserFIRST                             = 430
	CreateParserFIXED                             = 431
	CreateParserFLUSH                             = 432
	CreateParserFOLLOWING                         = 433
	CreateParserFOLLOWS                           = 434
	CreateParserFOUND                             = 435
	CreateParserFULL                              = 436
	CreateParserFUNCTION                          = 437
	CreateParserGENERAL                           = 438
	CreateParserGLOBAL                            = 439
	CreateParserGRANTS                            = 440
	CreateParserGROUP_REPLICATION                 = 441
	CreateParserHANDLER                           = 442
	CreateParserHASH                              = 443
	CreateParserHELP                              = 444
	CreateParserHISTORY                           = 445
	CreateParserHOST                              = 446
	CreateParserHOSTS                             = 447
	CreateParserIDENTIFIED                        = 448
	CreateParserIGNORE_SERVER_IDS                 = 449
	CreateParserIMPORT                            = 450
	CreateParserINCREMENT                         = 451
	CreateParserINDEXES                           = 452
	CreateParserINITIAL_SIZE                      = 453
	CreateParserINPLACE                           = 454
	CreateParserINSERT_METHOD                     = 455
	CreateParserINSTALL                           = 456
	CreateParserINSTANCE                          = 457
	CreateParserINSTANT                           = 458
	CreateParserINVISIBLE                         = 459
	CreateParserINVOKER                           = 460
	CreateParserIO                                = 461
	CreateParserIO_THREAD                         = 462
	CreateParserIPC                               = 463
	CreateParserISOLATION                         = 464
	CreateParserISSUER                            = 465
	CreateParserJSON                              = 466
	CreateParserKEY_BLOCK_SIZE                    = 467
	CreateParserLANGUAGE                          = 468
	CreateParserLAST                              = 469
	CreateParserLEAVES                            = 470
	CreateParserLESS                              = 471
	CreateParserLEVEL                             = 472
	CreateParserLIST                              = 473
	CreateParserLOCAL                             = 474
	CreateParserLOGFILE                           = 475
	CreateParserLOGS                              = 476
	CreateParserMASTER                            = 477
	CreateParserMASTER_AUTO_POSITION              = 478
	CreateParserMASTER_CONNECT_RETRY              = 479
	CreateParserMASTER_DELAY                      = 480
	CreateParserMASTER_HEARTBEAT_PERIOD           = 481
	CreateParserMASTER_HOST                       = 482
	CreateParserMASTER_LOG_FILE                   = 483
	CreateParserMASTER_LOG_POS                    = 484
	CreateParserMASTER_PASSWORD                   = 485
	CreateParserMASTER_PORT                       = 486
	CreateParserMASTER_RETRY_COUNT                = 487
	CreateParserMASTER_SSL                        = 488
	CreateParserMASTER_SSL_CA                     = 489
	CreateParserMASTER_SSL_CAPATH                 = 490
	CreateParserMASTER_SSL_CERT                   = 491
	CreateParserMASTER_SSL_CIPHER                 = 492
	CreateParserMASTER_SSL_CRL                    = 493
	CreateParserMASTER_SSL_CRLPATH                = 494
	CreateParserMASTER_SSL_KEY                    = 495
	CreateParserMASTER_TLS_VERSION                = 496
	CreateParserMASTER_USER                       = 497
	CreateParserMAX_CONNECTIONS_PER_HOUR          = 498
	CreateParserMAX_QUERIES_PER_HOUR              = 499
	CreateParserMAX_ROWS                          = 500
	CreateParserMAX_SIZE                          = 501
	CreateParserMAX_UPDATES_PER_HOUR              = 502
	CreateParserMAX_USER_CONNECTIONS              = 503
	CreateParserMEDIUM                            = 504
	CreateParserMEMBER                            = 505
	CreateParserMERGE                             = 506
	CreateParserMESSAGE_TEXT                      = 507
	CreateParserMID                               = 508
	CreateParserMIGRATE                           = 509
	CreateParserMIN_ROWS                          = 510
	CreateParserMODE                              = 511
	CreateParserMODIFY                            = 512
	CreateParserMUTEX                             = 513
	CreateParserMYSQL                             = 514
	CreateParserMYSQL_ERRNO                       = 515
	CreateParserNAME                              = 516
	CreateParserNAMES                             = 517
	CreateParserNCHAR                             = 518
	CreateParserNEVER                             = 519
	CreateParserNEXT                              = 520
	CreateParserNO                                = 521
	CreateParserNOCACHE                           = 522
	CreateParserNOCOPY                            = 523
	CreateParserNOCYCLE                           = 524
	CreateParserNOMAXVALUE                        = 525
	CreateParserNOMINVALUE                        = 526
	CreateParserNOWAIT                            = 527
	CreateParserNODEGROUP                         = 528
	CreateParserNONE                              = 529
	CreateParserODBC                              = 530
	CreateParserOFFLINE                           = 531
	CreateParserOFFSET                            = 532
	CreateParserOF                                = 533
	CreateParserOJ                                = 534
	CreateParserOLD_PASSWORD                      = 535
	CreateParserONE                               = 536
	CreateParserONLINE                            = 537
	CreateParserONLY                              = 538
	CreateParserOPEN                              = 539
	CreateParserOPTIMIZER_COSTS                   = 540
	CreateParserOPTIONS                           = 541
	CreateParserOWNER                             = 542
	CreateParserPACK_KEYS                         = 543
	CreateParserPAGE                              = 544
	CreateParserPAGE_COMPRESSED                   = 545
	CreateParserPAGE_COMPRESSION_LEVEL            = 546
	CreateParserPARSER                            = 547
	CreateParserPARTIAL                           = 548
	CreateParserPARTITIONING                      = 549
	CreateParserPARTITIONS                        = 550
	CreateParserPASSWORD                          = 551
	CreateParserPASSWORD_LOCK_TIME                = 552
	CreateParserPHASE                             = 553
	CreateParserPLUGIN                            = 554
	CreateParserPLUGIN_DIR                        = 555
	CreateParserPLUGINS                           = 556
	CreateParserPORT                              = 557
	CreateParserPRECEDES                          = 558
	CreateParserPRECEDING                         = 559
	CreateParserPREPARE                           = 560
	CreateParserPRESERVE                          = 561
	CreateParserPREV                              = 562
	CreateParserPROCESSLIST                       = 563
	CreateParserPROFILE                           = 564
	CreateParserPROFILES                          = 565
	CreateParserPROXY                             = 566
	CreateParserQUERY                             = 567
	CreateParserQUICK                             = 568
	CreateParserREBUILD                           = 569
	CreateParserRECOVER                           = 570
	CreateParserRECURSIVE                         = 571
	CreateParserREDO_BUFFER_SIZE                  = 572
	CreateParserREDUNDANT                         = 573
	CreateParserRELAY                             = 574
	CreateParserRELAY_LOG_FILE                    = 575
	CreateParserRELAY_LOG_POS                     = 576
	CreateParserRELAYLOG                          = 577
	CreateParserREMOVE                            = 578
	CreateParserREORGANIZE                        = 579
	CreateParserREPAIR                            = 580
	CreateParserREPLICATE_DO_DB                   = 581
	CreateParserREPLICATE_DO_TABLE                = 582
	CreateParserREPLICATE_IGNORE_DB               = 583
	CreateParserREPLICATE_IGNORE_TABLE            = 584
	CreateParserREPLICATE_REWRITE_DB              = 585
	CreateParserREPLICATE_WILD_DO_TABLE           = 586
	CreateParserREPLICATE_WILD_IGNORE_TABLE       = 587
	CreateParserREPLICATION                       = 588
	CreateParserRESET                             = 589
	CreateParserRESTART                           = 590
	CreateParserRESUME                            = 591
	CreateParserRETURNED_SQLSTATE                 = 592
	CreateParserRETURNING                         = 593
	CreateParserRETURNS                           = 594
	CreateParserREUSE                             = 595
	CreateParserROLE                              = 596
	CreateParserROLLBACK                          = 597
	CreateParserROLLUP                            = 598
	CreateParserROTATE                            = 599
	CreateParserROW                               = 600
	CreateParserROWS                              = 601
	CreateParserROW_FORMAT                        = 602
	CreateParserRTREE                             = 603
	CreateParserSAVEPOINT                         = 604
	CreateParserSCHEDULE                          = 605
	CreateParserSECURITY                          = 606
	CreateParserSEQUENCE                          = 607
	CreateParserSERVER                            = 608
	CreateParserSESSION                           = 609
	CreateParserSHARE                             = 610
	CreateParserSHARED                            = 611
	CreateParserSIGNED                            = 612
	CreateParserSIMPLE                            = 613
	CreateParserSLAVE                             = 614
	CreateParserSLOW                              = 615
	CreateParserSNAPSHOT                          = 616
	CreateParserSOCKET                            = 617
	CreateParserSOME                              = 618
	CreateParserSONAME                            = 619
	CreateParserSOUNDS                            = 620
	CreateParserSOURCE                            = 621
	CreateParserSQL_AFTER_GTIDS                   = 622
	CreateParserSQL_AFTER_MTS_GAPS                = 623
	CreateParserSQL_BEFORE_GTIDS                  = 624
	CreateParserSQL_BUFFER_RESULT                 = 625
	CreateParserSQL_CACHE                         = 626
	CreateParserSQL_NO_CACHE                      = 627
	CreateParserSQL_THREAD                        = 628
	CreateParserSTART                             = 629
	CreateParserSTARTS                            = 630
	CreateParserSTATS_AUTO_RECALC                 = 631
	CreateParserSTATS_PERSISTENT                  = 632
	CreateParserSTATS_SAMPLE_PAGES                = 633
	CreateParserSTATUS                            = 634
	CreateParserSTOP                              = 635
	CreateParserSTORAGE                           = 636
	CreateParserSTORED                            = 637
	CreateParserSTRING                            = 638
	CreateParserSUBCLASS_ORIGIN                   = 639
	CreateParserSUBJECT                           = 640
	CreateParserSUBPARTITION                      = 641
	CreateParserSUBPARTITIONS                     = 642
	CreateParserSUSPEND                           = 643
	CreateParserSWAPS                             = 644
	CreateParserSWITCHES                          = 645
	CreateParserTABLE_NAME                        = 646
	CreateParserTABLESPACE                        = 647
	CreateParserTABLE_TYPE                        = 648
	CreateParserTEMPORARY                         = 649
	CreateParserTEMPTABLE                         = 650
	CreateParserTHAN                              = 651
	CreateParserTRADITIONAL                       = 652
	CreateParserTRANSACTION                       = 653
	CreateParserTRANSACTIONAL                     = 654
	CreateParserTRIGGERS                          = 655
	CreateParserTRUNCATE                          = 656
	CreateParserUNBOUNDED                         = 657
	CreateParserUNDEFINED                         = 658
	CreateParserUNDOFILE                          = 659
	CreateParserUNDO_BUFFER_SIZE                  = 660
	CreateParserUNINSTALL                         = 661
	CreateParserUNKNOWN                           = 662
	CreateParserUNTIL                             = 663
	CreateParserUPGRADE                           = 664
	CreateParserUSER                              = 665
	CreateParserUSE_FRM                           = 666
	CreateParserUSER_RESOURCES                    = 667
	CreateParserVALIDATION                        = 668
	CreateParserVALUE                             = 669
	CreateParserVARIABLES                         = 670
	CreateParserVIEW                              = 671
	CreateParserVIRTUAL                           = 672
	CreateParserVISIBLE                           = 673
	CreateParserWAIT                              = 674
	CreateParserWARNINGS                          = 675
	CreateParserWINDOW                            = 676
	CreateParserWITHOUT                           = 677
	CreateParserWORK                              = 678
	CreateParserWRAPPER                           = 679
	CreateParserX509                              = 680
	CreateParserXA                                = 681
	CreateParserXML                               = 682
	CreateParserYES                               = 683
	CreateParserEUR                               = 684
	CreateParserUSA                               = 685
	CreateParserJIS                               = 686
	CreateParserISO                               = 687
	CreateParserINTERNAL                          = 688
	CreateParserQUARTER                           = 689
	CreateParserMONTH                             = 690
	CreateParserDAY                               = 691
	CreateParserHOUR                              = 692
	CreateParserMINUTE                            = 693
	CreateParserWEEK                              = 694
	CreateParserSECOND                            = 695
	CreateParserMICROSECOND                       = 696
	CreateParserADMIN                             = 697
	CreateParserAPPLICATION_PASSWORD_ADMIN        = 698
	CreateParserAUDIT_ABORT_EXEMPT                = 699
	CreateParserAUDIT_ADMIN                       = 700
	CreateParserAUTHENTICATION_POLICY_ADMIN       = 701
	CreateParserBACKUP_ADMIN                      = 702
	CreateParserBINLOG_ADMIN                      = 703
	CreateParserBINLOG_ENCRYPTION_ADMIN           = 704
	CreateParserCLONE_ADMIN                       = 705
	CreateParserCONNECTION_ADMIN                  = 706
	CreateParserENCRYPTION_KEY_ADMIN              = 707
	CreateParserEXECUTE                           = 708
	CreateParserFILE                              = 709
	CreateParserFIREWALL_ADMIN                    = 710
	CreateParserFIREWALL_EXEMPT                   = 711
	CreateParserFIREWALL_USER                     = 712
	CreateParserFLUSH_OPTIMIZER_COSTS             = 713
	CreateParserFLUSH_STATUS                      = 714
	CreateParserFLUSH_TABLES                      = 715
	CreateParserFLUSH_USER_RESOURCES              = 716
	CreateParserGROUP_REPLICATION_ADMIN           = 717
	CreateParserINNODB_REDO_LOG_ARCHIVE           = 718
	CreateParserINNODB_REDO_LOG_ENABLE            = 719
	CreateParserINVOKE                            = 720
	CreateParserLAMBDA                            = 721
	CreateParserNDB_STORED_USER                   = 722
	CreateParserPASSWORDLESS_USER_ADMIN           = 723
	CreateParserPERSIST_RO_VARIABLES_ADMIN        = 724
	CreateParserPRIVILEGES                        = 725
	CreateParserPROCESS                           = 726
	CreateParserRELOAD                            = 727
	CreateParserREPLICATION_APPLIER               = 728
	CreateParserREPLICATION_SLAVE_ADMIN           = 729
	CreateParserRESOURCE_GROUP_ADMIN              = 730
	CreateParserRESOURCE_GROUP_USER               = 731
	CreateParserROLE_ADMIN                        = 732
	CreateParserROUTINE                           = 733
	CreateParserS3                                = 734
	CreateParserSERVICE_CONNECTION_ADMIN          = 735
	CreateParserSESSION_VARIABLES_ADMIN           = 736
	CreateParserSET_USER_ID                       = 737
	CreateParserSHOW_ROUTINE                      = 738
	CreateParserSHUTDOWN                          = 739
	CreateParserSUPER                             = 740
	CreateParserSYSTEM_VARIABLES_ADMIN            = 741
	CreateParserTABLES                            = 742
	CreateParserTABLE_ENCRYPTION_ADMIN            = 743
	CreateParserVERSION_TOKEN_ADMIN               = 744
	CreateParserXA_RECOVER_ADMIN                  = 745
	CreateParserARMSCII8                          = 746
	CreateParserASCII                             = 747
	CreateParserBIG5                              = 748
	CreateParserCP1250                            = 749
	CreateParserCP1251                            = 750
	CreateParserCP1256                            = 751
	CreateParserCP1257                            = 752
	CreateParserCP850                             = 753
	CreateParserCP852                             = 754
	CreateParserCP866                             = 755
	CreateParserCP932                             = 756
	CreateParserDEC8                              = 757
	CreateParserEUCJPMS                           = 758
	CreateParserEUCKR                             = 759
	CreateParserGB18030                           = 760
	CreateParserGB2312                            = 761
	CreateParserGBK                               = 762
	CreateParserGEOSTD8                           = 763
	CreateParserGREEK                             = 764
	CreateParserHEBREW                            = 765
	CreateParserHP8                               = 766
	CreateParserKEYBCS2                           = 767
	CreateParserKOI8R                             = 768
	CreateParserKOI8U                             = 769
	CreateParserLATIN1                            = 770
	CreateParserLATIN2                            = 771
	CreateParserLATIN5                            = 772
	CreateParserLATIN7                            = 773
	CreateParserMACCE                             = 774
	CreateParserMACROMAN                          = 775
	CreateParserSJIS                              = 776
	CreateParserSWE7                              = 777
	CreateParserTIS620                            = 778
	CreateParserUCS2                              = 779
	CreateParserUJIS                              = 780
	CreateParserUTF16                             = 781
	CreateParserUTF16LE                           = 782
	CreateParserUTF32                             = 783
	CreateParserUTF8                              = 784
	CreateParserUTF8MB3                           = 785
	CreateParserUTF8MB4                           = 786
	CreateParserARCHIVE                           = 787
	CreateParserBLACKHOLE                         = 788
	CreateParserCSV                               = 789
	CreateParserFEDERATED                         = 790
	CreateParserINNODB                            = 791
	CreateParserMEMORY                            = 792
	CreateParserMRG_MYISAM                        = 793
	CreateParserMYISAM                            = 794
	CreateParserNDB                               = 795
	CreateParserNDBCLUSTER                        = 796
	CreateParserPERFORMANCE_SCHEMA                = 797
	CreateParserTOKUDB                            = 798
	CreateParserREPEATABLE                        = 799
	CreateParserCOMMITTED                         = 800
	CreateParserUNCOMMITTED                       = 801
	CreateParserSERIALIZABLE                      = 802
	CreateParserGEOMETRYCOLLECTION                = 803
	CreateParserGEOMCOLLECTION                    = 804
	CreateParserGEOMETRY                          = 805
	CreateParserLINESTRING                        = 806
	CreateParserMULTILINESTRING                   = 807
	CreateParserMULTIPOINT                        = 808
	CreateParserMULTIPOLYGON                      = 809
	CreateParserPOINT                             = 810
	CreateParserPOLYGON                           = 811
	CreateParserABS                               = 812
	CreateParserACOS                              = 813
	CreateParserADDDATE                           = 814
	CreateParserADDTIME                           = 815
	CreateParserAES_DECRYPT                       = 816
	CreateParserAES_ENCRYPT                       = 817
	CreateParserAREA                              = 818
	CreateParserASBINARY                          = 819
	CreateParserASIN                              = 820
	CreateParserASTEXT                            = 821
	CreateParserASWKB                             = 822
	CreateParserASWKT                             = 823
	CreateParserASYMMETRIC_DECRYPT                = 824
	CreateParserASYMMETRIC_DERIVE                 = 825
	CreateParserASYMMETRIC_ENCRYPT                = 826
	CreateParserASYMMETRIC_SIGN                   = 827
	CreateParserASYMMETRIC_VERIFY                 = 828
	CreateParserATAN                              = 829
	CreateParserATAN2                             = 830
	CreateParserBENCHMARK                         = 831
	CreateParserBIN                               = 832
	CreateParserBIT_COUNT                         = 833
	CreateParserBIT_LENGTH                        = 834
	CreateParserBUFFER                            = 835
	CreateParserCATALOG_NAME                      = 836
	CreateParserCEIL                              = 837
	CreateParserCEILING                           = 838
	CreateParserCENTROID                          = 839
	CreateParserCHARACTER_LENGTH                  = 840
	CreateParserCHARSET                           = 841
	CreateParserCHAR_LENGTH                       = 842
	CreateParserCOERCIBILITY                      = 843
	CreateParserCOLLATION                         = 844
	CreateParserCOMPRESS                          = 845
	CreateParserCONCAT                            = 846
	CreateParserCONCAT_WS                         = 847
	CreateParserCONNECTION_ID                     = 848
	CreateParserCONV                              = 849
	CreateParserCONVERT_TZ                        = 850
	CreateParserCOS                               = 851
	CreateParserCOT                               = 852
	CreateParserCRC32                             = 853
	CreateParserCREATE_ASYMMETRIC_PRIV_KEY        = 854
	CreateParserCREATE_ASYMMETRIC_PUB_KEY         = 855
	CreateParserCREATE_DH_PARAMETERS              = 856
	CreateParserCREATE_DIGEST                     = 857
	CreateParserCROSSES                           = 858
	CreateParserDATEDIFF                          = 859
	CreateParserDATE_FORMAT                       = 860
	CreateParserDAYNAME                           = 861
	CreateParserDAYOFMONTH                        = 862
	CreateParserDAYOFWEEK                         = 863
	CreateParserDAYOFYEAR                         = 864
	CreateParserDECODE                            = 865
	CreateParserDEGREES                           = 866
	CreateParserDES_DECRYPT                       = 867
	CreateParserDES_ENCRYPT                       = 868
	CreateParserDIMENSION                         = 869
	CreateParserDISJOINT                          = 870
	CreateParserELT                               = 871
	CreateParserENCODE                            = 872
	CreateParserENCRYPT                           = 873
	CreateParserENDPOINT                          = 874
	CreateParserENGINE_ATTRIBUTE                  = 875
	CreateParserENVELOPE                          = 876
	CreateParserEQUALS                            = 877
	CreateParserEXP                               = 878
	CreateParserEXPORT_SET                        = 879
	CreateParserEXTERIORRING                      = 880
	CreateParserEXTRACTVALUE                      = 881
	CreateParserFIELD                             = 882
	CreateParserFIND_IN_SET                       = 883
	CreateParserFLOOR                             = 884
	CreateParserFORMAT                            = 885
	CreateParserFOUND_ROWS                        = 886
	CreateParserFROM_BASE64                       = 887
	CreateParserFROM_DAYS                         = 888
	CreateParserFROM_UNIXTIME                     = 889
	CreateParserGEOMCOLLFROMTEXT                  = 890
	CreateParserGEOMCOLLFROMWKB                   = 891
	CreateParserGEOMETRYCOLLECTIONFROMTEXT        = 892
	CreateParserGEOMETRYCOLLECTIONFROMWKB         = 893
	CreateParserGEOMETRYFROMTEXT                  = 894
	CreateParserGEOMETRYFROMWKB                   = 895
	CreateParserGEOMETRYN                         = 896
	CreateParserGEOMETRYTYPE                      = 897
	CreateParserGEOMFROMTEXT                      = 898
	CreateParserGEOMFROMWKB                       = 899
	CreateParserGET_FORMAT                        = 900
	CreateParserGET_LOCK                          = 901
	CreateParserGLENGTH                           = 902
	CreateParserGREATEST                          = 903
	CreateParserGTID_SUBSET                       = 904
	CreateParserGTID_SUBTRACT                     = 905
	CreateParserHEX                               = 906
	CreateParserIFNULL                            = 907
	CreateParserINET6_ATON                        = 908
	CreateParserINET6_NTOA                        = 909
	CreateParserINET_ATON                         = 910
	CreateParserINET_NTOA                         = 911
	CreateParserINSTR                             = 912
	CreateParserINTERIORRINGN                     = 913
	CreateParserINTERSECTS                        = 914
	CreateParserISCLOSED                          = 915
	CreateParserISEMPTY                           = 916
	CreateParserISNULL                            = 917
	CreateParserISSIMPLE                          = 918
	CreateParserIS_FREE_LOCK                      = 919
	CreateParserIS_IPV4                           = 920
	CreateParserIS_IPV4_COMPAT                    = 921
	CreateParserIS_IPV4_MAPPED                    = 922
	CreateParserIS_IPV6                           = 923
	CreateParserIS_USED_LOCK                      = 924
	CreateParserLAST_INSERT_ID                    = 925
	CreateParserLCASE                             = 926
	CreateParserLEAST                             = 927
	CreateParserLENGTH                            = 928
	CreateParserLINEFROMTEXT                      = 929
	CreateParserLINEFROMWKB                       = 930
	CreateParserLINESTRINGFROMTEXT                = 931
	CreateParserLINESTRINGFROMWKB                 = 932
	CreateParserLN                                = 933
	CreateParserLOAD_FILE                         = 934
	CreateParserLOCATE                            = 935
	CreateParserLOG                               = 936
	CreateParserLOG10                             = 937
	CreateParserLOG2                              = 938
	CreateParserLOWER                             = 939
	CreateParserLPAD                              = 940
	CreateParserLTRIM                             = 941
	CreateParserMAKEDATE                          = 942
	CreateParserMAKETIME                          = 943
	CreateParserMAKE_SET                          = 944
	CreateParserMASTER_POS_WAIT                   = 945
	CreateParserMBRCONTAINS                       = 946
	CreateParserMBRDISJOINT                       = 947
	CreateParserMBREQUAL                          = 948
	CreateParserMBRINTERSECTS                     = 949
	CreateParserMBROVERLAPS                       = 950
	CreateParserMBRTOUCHES                        = 951
	CreateParserMBRWITHIN                         = 952
	CreateParserMD5                               = 953
	CreateParserMLINEFROMTEXT                     = 954
	CreateParserMLINEFROMWKB                      = 955
	CreateParserMONTHNAME                         = 956
	CreateParserMPOINTFROMTEXT                    = 957
	CreateParserMPOINTFROMWKB                     = 958
	CreateParserMPOLYFROMTEXT                     = 959
	CreateParserMPOLYFROMWKB                      = 960
	CreateParserMULTILINESTRINGFROMTEXT           = 961
	CreateParserMULTILINESTRINGFROMWKB            = 962
	CreateParserMULTIPOINTFROMTEXT                = 963
	CreateParserMULTIPOINTFROMWKB                 = 964
	CreateParserMULTIPOLYGONFROMTEXT              = 965
	CreateParserMULTIPOLYGONFROMWKB               = 966
	CreateParserNAME_CONST                        = 967
	CreateParserNULLIF                            = 968
	CreateParserNUMGEOMETRIES                     = 969
	CreateParserNUMINTERIORRINGS                  = 970
	CreateParserNUMPOINTS                         = 971
	CreateParserOCT                               = 972
	CreateParserOCTET_LENGTH                      = 973
	CreateParserORD                               = 974
	CreateParserOVERLAPS                          = 975
	CreateParserPERIOD_ADD                        = 976
	CreateParserPERIOD_DIFF                       = 977
	CreateParserPI                                = 978
	CreateParserPOINTFROMTEXT                     = 979
	CreateParserPOINTFROMWKB                      = 980
	CreateParserPOINTN                            = 981
	CreateParserPOLYFROMTEXT                      = 982
	CreateParserPOLYFROMWKB                       = 983
	CreateParserPOLYGONFROMTEXT                   = 984
	CreateParserPOLYGONFROMWKB                    = 985
	CreateParserPOW                               = 986
	CreateParserPOWER                             = 987
	CreateParserQUOTE                             = 988
	CreateParserRADIANS                           = 989
	CreateParserRAND                              = 990
	CreateParserRANDOM                            = 991
	CreateParserRANDOM_BYTES                      = 992
	CreateParserRELEASE_LOCK                      = 993
	CreateParserREVERSE                           = 994
	CreateParserROUND                             = 995
	CreateParserROW_COUNT                         = 996
	CreateParserRPAD                              = 997
	CreateParserRTRIM                             = 998
	CreateParserSEC_TO_TIME                       = 999
	CreateParserSECONDARY_ENGINE_ATTRIBUTE        = 1000
	CreateParserSESSION_USER                      = 1001
	CreateParserSHA                               = 1002
	CreateParserSHA1                              = 1003
	CreateParserSHA2                              = 1004
	CreateParserSCHEMA_NAME                       = 1005
	CreateParserSIGN                              = 1006
	CreateParserSIN                               = 1007
	CreateParserSLEEP                             = 1008
	CreateParserSOUNDEX                           = 1009
	CreateParserSQL_THREAD_WAIT_AFTER_GTIDS       = 1010
	CreateParserSQRT                              = 1011
	CreateParserSRID                              = 1012
	CreateParserSTARTPOINT                        = 1013
	CreateParserSTRCMP                            = 1014
	CreateParserSTR_TO_DATE                       = 1015
	CreateParserST_AREA                           = 1016
	CreateParserST_ASBINARY                       = 1017
	CreateParserST_ASTEXT                         = 1018
	CreateParserST_ASWKB                          = 1019
	CreateParserST_ASWKT                          = 1020
	CreateParserST_BUFFER                         = 1021
	CreateParserST_CENTROID                       = 1022
	CreateParserST_CONTAINS                       = 1023
	CreateParserST_CROSSES                        = 1024
	CreateParserST_DIFFERENCE                     = 1025
	CreateParserST_DIMENSION                      = 1026
	CreateParserST_DISJOINT                       = 1027
	CreateParserST_DISTANCE                       = 1028
	CreateParserST_ENDPOINT                       = 1029
	CreateParserST_ENVELOPE                       = 1030
	CreateParserST_EQUALS                         = 1031
	CreateParserST_EXTERIORRING                   = 1032
	CreateParserST_GEOMCOLLFROMTEXT               = 1033
	CreateParserST_GEOMCOLLFROMTXT                = 1034
	CreateParserST_GEOMCOLLFROMWKB                = 1035
	CreateParserST_GEOMETRYCOLLECTIONFROMTEXT     = 1036
	CreateParserST_GEOMETRYCOLLECTIONFROMWKB      = 1037
	CreateParserST_GEOMETRYFROMTEXT               = 1038
	CreateParserST_GEOMETRYFROMWKB                = 1039
	CreateParserST_GEOMETRYN                      = 1040
	CreateParserST_GEOMETRYTYPE                   = 1041
	CreateParserST_GEOMFROMTEXT                   = 1042
	CreateParserST_GEOMFROMWKB                    = 1043
	CreateParserST_INTERIORRINGN                  = 1044
	CreateParserST_INTERSECTION                   = 1045
	CreateParserST_INTERSECTS                     = 1046
	CreateParserST_ISCLOSED                       = 1047
	CreateParserST_ISEMPTY                        = 1048
	CreateParserST_ISSIMPLE                       = 1049
	CreateParserST_LINEFROMTEXT                   = 1050
	CreateParserST_LINEFROMWKB                    = 1051
	CreateParserST_LINESTRINGFROMTEXT             = 1052
	CreateParserST_LINESTRINGFROMWKB              = 1053
	CreateParserST_NUMGEOMETRIES                  = 1054
	CreateParserST_NUMINTERIORRING                = 1055
	CreateParserST_NUMINTERIORRINGS               = 1056
	CreateParserST_NUMPOINTS                      = 1057
	CreateParserST_OVERLAPS                       = 1058
	CreateParserST_POINTFROMTEXT                  = 1059
	CreateParserST_POINTFROMWKB                   = 1060
	CreateParserST_POINTN                         = 1061
	CreateParserST_POLYFROMTEXT                   = 1062
	CreateParserST_POLYFROMWKB                    = 1063
	CreateParserST_POLYGONFROMTEXT                = 1064
	CreateParserST_POLYGONFROMWKB                 = 1065
	CreateParserST_SRID                           = 1066
	CreateParserST_STARTPOINT                     = 1067
	CreateParserST_SYMDIFFERENCE                  = 1068
	CreateParserST_TOUCHES                        = 1069
	CreateParserST_UNION                          = 1070
	CreateParserST_WITHIN                         = 1071
	CreateParserST_X                              = 1072
	CreateParserST_Y                              = 1073
	CreateParserSUBDATE                           = 1074
	CreateParserSUBSTRING_INDEX                   = 1075
	CreateParserSUBTIME                           = 1076
	CreateParserSYSTEM_USER                       = 1077
	CreateParserTAN                               = 1078
	CreateParserTIMEDIFF                          = 1079
	CreateParserTIMESTAMPADD                      = 1080
	CreateParserTIMESTAMPDIFF                     = 1081
	CreateParserTIME_FORMAT                       = 1082
	CreateParserTIME_TO_SEC                       = 1083
	CreateParserTOUCHES                           = 1084
	CreateParserTO_BASE64                         = 1085
	CreateParserTO_DAYS                           = 1086
	CreateParserTO_SECONDS                        = 1087
	CreateParserTP_CONNECTION_ADMIN               = 1088
	CreateParserUCASE                             = 1089
	CreateParserUNCOMPRESS                        = 1090
	CreateParserUNCOMPRESSED_LENGTH               = 1091
	CreateParserUNHEX                             = 1092
	CreateParserUNIX_TIMESTAMP                    = 1093
	CreateParserUPDATEXML                         = 1094
	CreateParserUPPER                             = 1095
	CreateParserUUID                              = 1096
	CreateParserUUID_SHORT                        = 1097
	CreateParserVALIDATE_PASSWORD_STRENGTH        = 1098
	CreateParserVERSION                           = 1099
	CreateParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 1100
	CreateParserWEEKDAY                           = 1101
	CreateParserWEEKOFYEAR                        = 1102
	CreateParserWEIGHT_STRING                     = 1103
	CreateParserWITHIN                            = 1104
	CreateParserYEARWEEK                          = 1105
	CreateParserY_FUNCTION                        = 1106
	CreateParserX_FUNCTION                        = 1107
	CreateParserVAR_ASSIGN                        = 1108
	CreateParserPLUS_ASSIGN                       = 1109
	CreateParserMINUS_ASSIGN                      = 1110
	CreateParserMULT_ASSIGN                       = 1111
	CreateParserDIV_ASSIGN                        = 1112
	CreateParserMOD_ASSIGN                        = 1113
	CreateParserAND_ASSIGN                        = 1114
	CreateParserXOR_ASSIGN                        = 1115
	CreateParserOR_ASSIGN                         = 1116
	CreateParserSTAR                              = 1117
	CreateParserDIVIDE                            = 1118
	CreateParserMODULE                            = 1119
	CreateParserPLUS                              = 1120
	CreateParserMINUS                             = 1121
	CreateParserDIV                               = 1122
	CreateParserMOD                               = 1123
	CreateParserEQUAL_SYMBOL                      = 1124
	CreateParserGREATER_SYMBOL                    = 1125
	CreateParserLESS_SYMBOL                       = 1126
	CreateParserEXCLAMATION_SYMBOL                = 1127
	CreateParserBIT_NOT_OP                        = 1128
	CreateParserBIT_OR_OP                         = 1129
	CreateParserBIT_AND_OP                        = 1130
	CreateParserBIT_XOR_OP                        = 1131
	CreateParserDOT                               = 1132
	CreateParserLR_BRACKET                        = 1133
	CreateParserRR_BRACKET                        = 1134
	CreateParserCOMMA                             = 1135
	CreateParserSEMI                              = 1136
	CreateParserAT_SIGN                           = 1137
	CreateParserZERO_DECIMAL                      = 1138
	CreateParserONE_DECIMAL                       = 1139
	CreateParserTWO_DECIMAL                       = 1140
	CreateParserSINGLE_QUOTE_SYMB                 = 1141
	CreateParserDOUBLE_QUOTE_SYMB                 = 1142
	CreateParserREVERSE_QUOTE_SYMB                = 1143
	CreateParserCOLON_SYMB                        = 1144
	CreateParserCHARSET_REVERSE_QOUTE_STRING      = 1145
	CreateParserFILESIZE_LITERAL                  = 1146
	CreateParserSTART_NATIONAL_STRING_LITERAL     = 1147
	CreateParserSTRING_LITERAL                    = 1148
	CreateParserDECIMAL_LITERAL                   = 1149
	CreateParserHEXADECIMAL_LITERAL               = 1150
	CreateParserREAL_LITERAL                      = 1151
	CreateParserNULL_SPEC_LITERAL                 = 1152
	CreateParserBIT_STRING                        = 1153
	CreateParserSTRING_CHARSET_NAME               = 1154
	CreateParserDIGTS                             = 1155
	CreateParserDOT_ID                            = 1156
	CreateParserID                                = 1157
	CreateParserCOLUMN_NAME_ID                    = 1158
	CreateParserTABLE_NAME_ID                     = 1159
	CreateParserDB_NAME_ID                        = 1160
	CreateParserREVERSE_QUOTE_ID                  = 1161
	CreateParserHOST_IP_ADDRESS                   = 1162
	CreateParserLOCAL_ID                          = 1163
	CreateParserGLOBAL_ID                         = 1164
	CreateParserERROR_RECONGNIGION                = 1165
)

// CreateParser rules.
const (
	CreateParserRULE_stat                        = 0
	CreateParserRULE_create_table                = 1
	CreateParserRULE_create_definition           = 2
	CreateParserRULE_column_definition           = 3
	CreateParserRULE_comment_defi                = 4
	CreateParserRULE_key_defi                    = 5
	CreateParserRULE_show_length                 = 6
	CreateParserRULE_data_type                   = 7
	CreateParserRULE_key_part                    = 8
	CreateParserRULE_index_type                  = 9
	CreateParserRULE_index_option                = 10
	CreateParserRULE_check_constraint_definition = 11
	CreateParserRULE_reference_definition        = 12
	CreateParserRULE_reference_option            = 13
	CreateParserRULE_table_options               = 14
	CreateParserRULE_table_option                = 15
	CreateParserRULE_partition_options           = 16
	CreateParserRULE_partition_definition        = 17
	CreateParserRULE_subpartition_definition     = 18
	CreateParserRULE_tablespace_option           = 19
	CreateParserRULE_tbl_name                    = 20
	CreateParserRULE_col_name                    = 21
	CreateParserRULE_tablespace_name             = 22
	CreateParserRULE_index_name                  = 23
	CreateParserRULE_engine_name                 = 24
	CreateParserRULE_symbol                      = 25
	CreateParserRULE_literal                     = 26
	CreateParserRULE_string                      = 27
	CreateParserRULE_collation_name              = 28
	CreateParserRULE_parser_name                 = 29
	CreateParserRULE_connect_string              = 30
	CreateParserRULE_charset_name                = 31
	CreateParserRULE_value                       = 32
	CreateParserRULE_length                      = 33
	CreateParserRULE_absolute_path_to_directory  = 34
	CreateParserRULE_expr                        = 35
	CreateParserRULE_num                         = 36
	CreateParserRULE_max_number_of_rows          = 37
	CreateParserRULE_min_number_of_rows          = 38
	CreateParserRULE_partition_name              = 39
	CreateParserRULE_logical_name                = 40
	CreateParserRULE_data_dir                    = 41
	CreateParserRULE_index_dir                   = 42
	CreateParserRULE_column_list                 = 43
	CreateParserRULE_value_list                  = 44
)

// IStatContext is an interface to support dynamic dispatch.
type IStatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Create_table() ICreate_tableContext
	EOF() antlr.TerminalNode

	// IsStatContext differentiates from other interfaces.
	IsStatContext()
}

type StatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatContext() *StatContext {
	var p = new(StatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_stat
	return p
}

func InitEmptyStatContext(p *StatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_stat
}

func (*StatContext) IsStatContext() {}

func NewStatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatContext {
	var p = new(StatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_stat

	return p
}

func (s *StatContext) GetParser() antlr.Parser { return s.parser }

func (s *StatContext) Create_table() ICreate_tableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_tableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_tableContext)
}

func (s *StatContext) EOF() antlr.TerminalNode {
	return s.GetToken(CreateParserEOF, 0)
}

func (s *StatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterStat(s)
	}
}

func (s *StatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitStat(s)
	}
}

func (p *CreateParser) Stat() (localctx IStatContext) {
	localctx = NewStatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CreateParserRULE_stat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(90)
		p.Create_table()
	}
	{
		p.SetState(91)
		p.Match(CreateParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_tableContext is an interface to support dynamic dispatch.
type ICreate_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tbl_name() ITbl_nameContext
	LR_BRACKET() antlr.TerminalNode
	AllCreate_definition() []ICreate_definitionContext
	Create_definition(i int) ICreate_definitionContext
	RR_BRACKET() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Table_options() ITable_optionsContext
	Partition_options() IPartition_optionsContext

	// IsCreate_tableContext differentiates from other interfaces.
	IsCreate_tableContext()
}

type Create_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_tableContext() *Create_tableContext {
	var p = new(Create_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_create_table
	return p
}

func InitEmptyCreate_tableContext(p *Create_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_create_table
}

func (*Create_tableContext) IsCreate_tableContext() {}

func NewCreate_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_tableContext {
	var p = new(Create_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_create_table

	return p
}

func (s *Create_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_tableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CreateParserCREATE, 0)
}

func (s *Create_tableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(CreateParserTABLE, 0)
}

func (s *Create_tableContext) Tbl_name() ITbl_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITbl_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITbl_nameContext)
}

func (s *Create_tableContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserLR_BRACKET, 0)
}

func (s *Create_tableContext) AllCreate_definition() []ICreate_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_definitionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_definitionContext); ok {
			tst[i] = t.(ICreate_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Create_tableContext) Create_definition(i int) ICreate_definitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_definitionContext)
}

func (s *Create_tableContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserRR_BRACKET, 0)
}

func (s *Create_tableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(CreateParserTEMPORARY, 0)
}

func (s *Create_tableContext) IF() antlr.TerminalNode {
	return s.GetToken(CreateParserIF, 0)
}

func (s *Create_tableContext) NOT() antlr.TerminalNode {
	return s.GetToken(CreateParserNOT, 0)
}

func (s *Create_tableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CreateParserEXISTS, 0)
}

func (s *Create_tableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CreateParserCOMMA)
}

func (s *Create_tableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMA, i)
}

func (s *Create_tableContext) Table_options() ITable_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_optionsContext)
}

func (s *Create_tableContext) Partition_options() IPartition_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_optionsContext)
}

func (s *Create_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterCreate_table(s)
	}
}

func (s *Create_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitCreate_table(s)
	}
}

func (p *CreateParser) Create_table() (localctx ICreate_tableContext) {
	localctx = NewCreate_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CreateParserRULE_create_table)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(93)
		p.Match(CreateParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(95)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserTEMPORARY {
		{
			p.SetState(94)
			p.Match(CreateParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(97)
		p.Match(CreateParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserIF {
		{
			p.SetState(98)
			p.Match(CreateParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(99)
			p.Match(CreateParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(100)
			p.Match(CreateParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(103)
		p.Tbl_name()
	}
	{
		p.SetState(104)
		p.Match(CreateParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(105)
		p.Create_definition()
	}
	p.SetState(110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CreateParserCOMMA {
		{
			p.SetState(106)
			p.Match(CreateParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(107)
			p.Create_definition()
		}

		p.SetState(112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(113)
		p.Match(CreateParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-25)) & ^0x3f) == 0 && ((int64(1)<<(_la-25))&72057594038059013) != 0) || _la == CreateParserUNION || ((int64((_la-341)) & ^0x3f) == 0 && ((int64(1)<<(_la-341))&4644371609714695) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&288300744895889409) != 0) || ((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&2260595906708481) != 0) || ((int64((_la-602)) & ^0x3f) == 0 && ((int64(1)<<(_la-602))&35205444272129) != 0) || _la == CreateParserENGINE_ATTRIBUTE || _la == CreateParserSECONDARY_ENGINE_ATTRIBUTE {
		{
			p.SetState(114)
			p.Table_options()
		}

	}
	p.SetState(118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserPARTITION {
		{
			p.SetState(117)
			p.Partition_options()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_definitionContext is an interface to support dynamic dispatch.
type ICreate_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Col_name() ICol_nameContext
	Column_definition() IColumn_definitionContext

	// IsCreate_definitionContext differentiates from other interfaces.
	IsCreate_definitionContext()
}

type Create_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_definitionContext() *Create_definitionContext {
	var p = new(Create_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_create_definition
	return p
}

func InitEmptyCreate_definitionContext(p *Create_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_create_definition
}

func (*Create_definitionContext) IsCreate_definitionContext() {}

func NewCreate_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_definitionContext {
	var p = new(Create_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_create_definition

	return p
}

func (s *Create_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_definitionContext) Col_name() ICol_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICol_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICol_nameContext)
}

func (s *Create_definitionContext) Column_definition() IColumn_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definitionContext)
}

func (s *Create_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterCreate_definition(s)
	}
}

func (s *Create_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitCreate_definition(s)
	}
}

func (p *CreateParser) Create_definition() (localctx ICreate_definitionContext) {
	localctx = NewCreate_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CreateParserRULE_create_definition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(120)
		p.Col_name()
	}
	{
		p.SetState(121)
		p.Column_definition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_definitionContext is an interface to support dynamic dispatch.
type IColumn_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Data_type() IData_typeContext
	Show_length() IShow_lengthContext
	NOT() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	Literal() ILiteralContext
	LR_BRACKET() antlr.TerminalNode
	Expr() IExprContext
	RR_BRACKET() antlr.TerminalNode
	Key_defi() IKey_defiContext
	Comment_defi() IComment_defiContext

	// IsColumn_definitionContext differentiates from other interfaces.
	IsColumn_definitionContext()
}

type Column_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_definitionContext() *Column_definitionContext {
	var p = new(Column_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_column_definition
	return p
}

func InitEmptyColumn_definitionContext(p *Column_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_column_definition
}

func (*Column_definitionContext) IsColumn_definitionContext() {}

func NewColumn_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_definitionContext {
	var p = new(Column_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_column_definition

	return p
}

func (s *Column_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_definitionContext) Data_type() IData_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IData_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Column_definitionContext) Show_length() IShow_lengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShow_lengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShow_lengthContext)
}

func (s *Column_definitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(CreateParserNOT, 0)
}

func (s *Column_definitionContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CreateParserNULL_LITERAL, 0)
}

func (s *Column_definitionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(CreateParserDEFAULT, 0)
}

func (s *Column_definitionContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(CreateParserAUTO_INCREMENT, 0)
}

func (s *Column_definitionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(CreateParserUNIQUE, 0)
}

func (s *Column_definitionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Column_definitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserLR_BRACKET, 0)
}

func (s *Column_definitionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Column_definitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserRR_BRACKET, 0)
}

func (s *Column_definitionContext) Key_defi() IKey_defiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKey_defiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKey_defiContext)
}

func (s *Column_definitionContext) Comment_defi() IComment_defiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComment_defiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComment_defiContext)
}

func (s *Column_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterColumn_definition(s)
	}
}

func (s *Column_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitColumn_definition(s)
	}
}

func (p *CreateParser) Column_definition() (localctx IColumn_definitionContext) {
	localctx = NewColumn_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CreateParserRULE_column_definition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(123)
		p.Data_type()
	}
	p.SetState(125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserLR_BRACKET {
		{
			p.SetState(124)
			p.Show_length()
		}

	}
	p.SetState(130)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case CreateParserNOT:
		{
			p.SetState(127)
			p.Match(CreateParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(128)
			p.Match(CreateParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CreateParserNULL_LITERAL:
		{
			p.SetState(129)
			p.Match(CreateParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CreateParserDEFAULT, CreateParserKEY, CreateParserPRIMARY, CreateParserUNIQUE, CreateParserAUTO_INCREMENT, CreateParserCOMMENT, CreateParserRR_BRACKET, CreateParserCOMMA:

	default:
	}
	p.SetState(140)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserDEFAULT {
		{
			p.SetState(132)
			p.Match(CreateParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CreateParserID:
			{
				p.SetState(133)
				p.Literal()
			}

		case CreateParserLR_BRACKET:
			{
				p.SetState(134)
				p.Match(CreateParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(135)
				p.Expr()
			}
			{
				p.SetState(136)
				p.Match(CreateParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(143)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserAUTO_INCREMENT {
		{
			p.SetState(142)
			p.Match(CreateParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserUNIQUE {
		{
			p.SetState(145)
			p.Match(CreateParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.SetState(149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserKEY || _la == CreateParserPRIMARY {
			{
				p.SetState(148)
				p.Key_defi()
			}

		}
		p.SetState(152)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserCOMMENT {
			{
				p.SetState(151)
				p.Comment_defi()
			}

		}

	case 2:
		p.SetState(155)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserCOMMENT {
			{
				p.SetState(154)
				p.Comment_defi()
			}

		}
		p.SetState(158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserKEY || _la == CreateParserPRIMARY {
			{
				p.SetState(157)
				p.Key_defi()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComment_defiContext is an interface to support dynamic dispatch.
type IComment_defiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCol_comment returns the col_comment rule contexts.
	GetCol_comment() IStringContext

	// SetCol_comment sets the col_comment rule contexts.
	SetCol_comment(IStringContext)

	// Getter signatures
	COMMENT() antlr.TerminalNode
	AllSINGLE_QUOTE_SYMB() []antlr.TerminalNode
	SINGLE_QUOTE_SYMB(i int) antlr.TerminalNode
	String_() IStringContext

	// IsComment_defiContext differentiates from other interfaces.
	IsComment_defiContext()
}

type Comment_defiContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	col_comment IStringContext
}

func NewEmptyComment_defiContext() *Comment_defiContext {
	var p = new(Comment_defiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_comment_defi
	return p
}

func InitEmptyComment_defiContext(p *Comment_defiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_comment_defi
}

func (*Comment_defiContext) IsComment_defiContext() {}

func NewComment_defiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comment_defiContext {
	var p = new(Comment_defiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_comment_defi

	return p
}

func (s *Comment_defiContext) GetParser() antlr.Parser { return s.parser }

func (s *Comment_defiContext) GetCol_comment() IStringContext { return s.col_comment }

func (s *Comment_defiContext) SetCol_comment(v IStringContext) { s.col_comment = v }

func (s *Comment_defiContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMENT, 0)
}

func (s *Comment_defiContext) AllSINGLE_QUOTE_SYMB() []antlr.TerminalNode {
	return s.GetTokens(CreateParserSINGLE_QUOTE_SYMB)
}

func (s *Comment_defiContext) SINGLE_QUOTE_SYMB(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserSINGLE_QUOTE_SYMB, i)
}

func (s *Comment_defiContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Comment_defiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comment_defiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comment_defiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterComment_defi(s)
	}
}

func (s *Comment_defiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitComment_defi(s)
	}
}

func (p *CreateParser) Comment_defi() (localctx IComment_defiContext) {
	localctx = NewComment_defiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CreateParserRULE_comment_defi)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(162)
		p.Match(CreateParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(163)
		p.Match(CreateParserSINGLE_QUOTE_SYMB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(164)

		var _x = p.String_()

		localctx.(*Comment_defiContext).col_comment = _x
	}
	{
		p.SetState(165)
		p.Match(CreateParserSINGLE_QUOTE_SYMB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKey_defiContext is an interface to support dynamic dispatch.
type IKey_defiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode

	// IsKey_defiContext differentiates from other interfaces.
	IsKey_defiContext()
}

type Key_defiContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKey_defiContext() *Key_defiContext {
	var p = new(Key_defiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_key_defi
	return p
}

func InitEmptyKey_defiContext(p *Key_defiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_key_defi
}

func (*Key_defiContext) IsKey_defiContext() {}

func NewKey_defiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Key_defiContext {
	var p = new(Key_defiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_key_defi

	return p
}

func (s *Key_defiContext) GetParser() antlr.Parser { return s.parser }

func (s *Key_defiContext) KEY() antlr.TerminalNode {
	return s.GetToken(CreateParserKEY, 0)
}

func (s *Key_defiContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(CreateParserPRIMARY, 0)
}

func (s *Key_defiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Key_defiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Key_defiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterKey_defi(s)
	}
}

func (s *Key_defiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitKey_defi(s)
	}
}

func (p *CreateParser) Key_defi() (localctx IKey_defiContext) {
	localctx = NewKey_defiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CreateParserRULE_key_defi)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(168)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserPRIMARY {
		{
			p.SetState(167)
			p.Match(CreateParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(170)
		p.Match(CreateParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShow_lengthContext is an interface to support dynamic dispatch.
type IShow_lengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	DIGTS() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsShow_lengthContext differentiates from other interfaces.
	IsShow_lengthContext()
}

type Show_lengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShow_lengthContext() *Show_lengthContext {
	var p = new(Show_lengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_show_length
	return p
}

func InitEmptyShow_lengthContext(p *Show_lengthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_show_length
}

func (*Show_lengthContext) IsShow_lengthContext() {}

func NewShow_lengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Show_lengthContext {
	var p = new(Show_lengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_show_length

	return p
}

func (s *Show_lengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Show_lengthContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserLR_BRACKET, 0)
}

func (s *Show_lengthContext) DIGTS() antlr.TerminalNode {
	return s.GetToken(CreateParserDIGTS, 0)
}

func (s *Show_lengthContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserRR_BRACKET, 0)
}

func (s *Show_lengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Show_lengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Show_lengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterShow_length(s)
	}
}

func (s *Show_lengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitShow_length(s)
	}
}

func (p *CreateParser) Show_length() (localctx IShow_lengthContext) {
	localctx = NewShow_lengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CreateParserRULE_show_length)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(172)
		p.Match(CreateParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(173)
		p.Match(CreateParserDIGTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(174)
		p.Match(CreateParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IData_typeContext is an interface to support dynamic dispatch.
type IData_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TINYINT() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	MEDIUMINT() antlr.TerminalNode
	MIDDLEINT() antlr.TerminalNode
	INT() antlr.TerminalNode
	INT1() antlr.TerminalNode
	INT2() antlr.TerminalNode
	INT3() antlr.TerminalNode
	INT4() antlr.TerminalNode
	INT8() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	REAL() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	PRECISION() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	FLOAT4() antlr.TerminalNode
	FLOAT8() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DEC() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	DATE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	NVARCHAR() antlr.TerminalNode
	NATIONAL() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	TINYBLOB() antlr.TerminalNode
	BLOB() antlr.TerminalNode
	MEDIUMBLOB() antlr.TerminalNode
	LONG() antlr.TerminalNode
	LONGBLOB() antlr.TerminalNode
	TINYTEXT() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	MEDIUMTEXT() antlr.TerminalNode
	LONGTEXT() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	VARYING() antlr.TerminalNode
	SERIAL() antlr.TerminalNode

	// IsData_typeContext differentiates from other interfaces.
	IsData_typeContext()
}

type Data_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_typeContext() *Data_typeContext {
	var p = new(Data_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_data_type
	return p
}

func InitEmptyData_typeContext(p *Data_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_data_type
}

func (*Data_typeContext) IsData_typeContext() {}

func NewData_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_typeContext {
	var p = new(Data_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_data_type

	return p
}

func (s *Data_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_typeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(CreateParserTINYINT, 0)
}

func (s *Data_typeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(CreateParserSMALLINT, 0)
}

func (s *Data_typeContext) MEDIUMINT() antlr.TerminalNode {
	return s.GetToken(CreateParserMEDIUMINT, 0)
}

func (s *Data_typeContext) MIDDLEINT() antlr.TerminalNode {
	return s.GetToken(CreateParserMIDDLEINT, 0)
}

func (s *Data_typeContext) INT() antlr.TerminalNode {
	return s.GetToken(CreateParserINT, 0)
}

func (s *Data_typeContext) INT1() antlr.TerminalNode {
	return s.GetToken(CreateParserINT1, 0)
}

func (s *Data_typeContext) INT2() antlr.TerminalNode {
	return s.GetToken(CreateParserINT2, 0)
}

func (s *Data_typeContext) INT3() antlr.TerminalNode {
	return s.GetToken(CreateParserINT3, 0)
}

func (s *Data_typeContext) INT4() antlr.TerminalNode {
	return s.GetToken(CreateParserINT4, 0)
}

func (s *Data_typeContext) INT8() antlr.TerminalNode {
	return s.GetToken(CreateParserINT8, 0)
}

func (s *Data_typeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(CreateParserINTEGER, 0)
}

func (s *Data_typeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(CreateParserBIGINT, 0)
}

func (s *Data_typeContext) REAL() antlr.TerminalNode {
	return s.GetToken(CreateParserREAL, 0)
}

func (s *Data_typeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(CreateParserDOUBLE, 0)
}

func (s *Data_typeContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(CreateParserPRECISION, 0)
}

func (s *Data_typeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(CreateParserFLOAT, 0)
}

func (s *Data_typeContext) FLOAT4() antlr.TerminalNode {
	return s.GetToken(CreateParserFLOAT4, 0)
}

func (s *Data_typeContext) FLOAT8() antlr.TerminalNode {
	return s.GetToken(CreateParserFLOAT8, 0)
}

func (s *Data_typeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(CreateParserDECIMAL, 0)
}

func (s *Data_typeContext) DEC() antlr.TerminalNode {
	return s.GetToken(CreateParserDEC, 0)
}

func (s *Data_typeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(CreateParserNUMERIC, 0)
}

func (s *Data_typeContext) DATE() antlr.TerminalNode {
	return s.GetToken(CreateParserDATE, 0)
}

func (s *Data_typeContext) TIME() antlr.TerminalNode {
	return s.GetToken(CreateParserTIME, 0)
}

func (s *Data_typeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(CreateParserTIMESTAMP, 0)
}

func (s *Data_typeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(CreateParserDATETIME, 0)
}

func (s *Data_typeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(CreateParserYEAR, 0)
}

func (s *Data_typeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(CreateParserCHAR, 0)
}

func (s *Data_typeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(CreateParserVARCHAR, 0)
}

func (s *Data_typeContext) NVARCHAR() antlr.TerminalNode {
	return s.GetToken(CreateParserNVARCHAR, 0)
}

func (s *Data_typeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(CreateParserNATIONAL, 0)
}

func (s *Data_typeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(CreateParserBINARY, 0)
}

func (s *Data_typeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(CreateParserVARBINARY, 0)
}

func (s *Data_typeContext) TINYBLOB() antlr.TerminalNode {
	return s.GetToken(CreateParserTINYBLOB, 0)
}

func (s *Data_typeContext) BLOB() antlr.TerminalNode {
	return s.GetToken(CreateParserBLOB, 0)
}

func (s *Data_typeContext) MEDIUMBLOB() antlr.TerminalNode {
	return s.GetToken(CreateParserMEDIUMBLOB, 0)
}

func (s *Data_typeContext) LONG() antlr.TerminalNode {
	return s.GetToken(CreateParserLONG, 0)
}

func (s *Data_typeContext) LONGBLOB() antlr.TerminalNode {
	return s.GetToken(CreateParserLONGBLOB, 0)
}

func (s *Data_typeContext) TINYTEXT() antlr.TerminalNode {
	return s.GetToken(CreateParserTINYTEXT, 0)
}

func (s *Data_typeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(CreateParserTEXT, 0)
}

func (s *Data_typeContext) MEDIUMTEXT() antlr.TerminalNode {
	return s.GetToken(CreateParserMEDIUMTEXT, 0)
}

func (s *Data_typeContext) LONGTEXT() antlr.TerminalNode {
	return s.GetToken(CreateParserLONGTEXT, 0)
}

func (s *Data_typeContext) ENUM() antlr.TerminalNode {
	return s.GetToken(CreateParserENUM, 0)
}

func (s *Data_typeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(CreateParserVARYING, 0)
}

func (s *Data_typeContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(CreateParserSERIAL, 0)
}

func (s *Data_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterData_type(s)
	}
}

func (s *Data_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitData_type(s)
	}
}

func (p *CreateParser) Data_type() (localctx IData_typeContext) {
	localctx = NewData_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CreateParserRULE_data_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(176)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&17592186044415) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKey_partContext is an interface to support dynamic dispatch.
type IKey_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Col_name() ICol_nameContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	Length() ILengthContext

	// IsKey_partContext differentiates from other interfaces.
	IsKey_partContext()
}

type Key_partContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKey_partContext() *Key_partContext {
	var p = new(Key_partContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_key_part
	return p
}

func InitEmptyKey_partContext(p *Key_partContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_key_part
}

func (*Key_partContext) IsKey_partContext() {}

func NewKey_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Key_partContext {
	var p = new(Key_partContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_key_part

	return p
}

func (s *Key_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Key_partContext) Col_name() ICol_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICol_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICol_nameContext)
}

func (s *Key_partContext) ASC() antlr.TerminalNode {
	return s.GetToken(CreateParserASC, 0)
}

func (s *Key_partContext) DESC() antlr.TerminalNode {
	return s.GetToken(CreateParserDESC, 0)
}

func (s *Key_partContext) Length() ILengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthContext)
}

func (s *Key_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Key_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Key_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterKey_part(s)
	}
}

func (s *Key_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitKey_part(s)
	}
}

func (p *CreateParser) Key_part() (localctx IKey_partContext) {
	localctx = NewKey_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CreateParserRULE_key_part)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserID {
		{
			p.SetState(178)
			p.Col_name()
		}
		p.SetState(180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserDECIMAL_LITERAL {
			{
				p.SetState(179)
				p.Length()
			}

		}

	}
	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserASC || _la == CreateParserDESC {
		{
			p.SetState(184)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CreateParserASC || _la == CreateParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_typeContext is an interface to support dynamic dispatch.
type IIndex_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	HASH() antlr.TerminalNode

	// IsIndex_typeContext differentiates from other interfaces.
	IsIndex_typeContext()
}

type Index_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_typeContext() *Index_typeContext {
	var p = new(Index_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_index_type
	return p
}

func InitEmptyIndex_typeContext(p *Index_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_index_type
}

func (*Index_typeContext) IsIndex_typeContext() {}

func NewIndex_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_typeContext {
	var p = new(Index_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_index_type

	return p
}

func (s *Index_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_typeContext) USING() antlr.TerminalNode {
	return s.GetToken(CreateParserUSING, 0)
}

func (s *Index_typeContext) BTREE() antlr.TerminalNode {
	return s.GetToken(CreateParserBTREE, 0)
}

func (s *Index_typeContext) HASH() antlr.TerminalNode {
	return s.GetToken(CreateParserHASH, 0)
}

func (s *Index_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterIndex_type(s)
	}
}

func (s *Index_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitIndex_type(s)
	}
}

func (p *CreateParser) Index_type() (localctx IIndex_typeContext) {
	localctx = NewIndex_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CreateParserRULE_index_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(187)
		p.Match(CreateParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(188)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CreateParserBTREE || _la == CreateParserHASH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_optionContext is an interface to support dynamic dispatch.
type IIndex_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY_BLOCK_SIZE() antlr.TerminalNode
	Index_type() IIndex_typeContext
	WITH() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	Parser_name() IParser_nameContext
	COMMENT() antlr.TerminalNode
	AllSINGLE_QUOTE_SYMB() []antlr.TerminalNode
	SINGLE_QUOTE_SYMB(i int) antlr.TerminalNode
	String_() IStringContext
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	Value() IValueContext

	// IsIndex_optionContext differentiates from other interfaces.
	IsIndex_optionContext()
}

type Index_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_optionContext() *Index_optionContext {
	var p = new(Index_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_index_option
	return p
}

func InitEmptyIndex_optionContext(p *Index_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_index_option
}

func (*Index_optionContext) IsIndex_optionContext() {}

func NewIndex_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_optionContext {
	var p = new(Index_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_index_option

	return p
}

func (s *Index_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_optionContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(CreateParserKEY_BLOCK_SIZE, 0)
}

func (s *Index_optionContext) Index_type() IIndex_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_typeContext)
}

func (s *Index_optionContext) WITH() antlr.TerminalNode {
	return s.GetToken(CreateParserWITH, 0)
}

func (s *Index_optionContext) PARSER() antlr.TerminalNode {
	return s.GetToken(CreateParserPARSER, 0)
}

func (s *Index_optionContext) Parser_name() IParser_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParser_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParser_nameContext)
}

func (s *Index_optionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMENT, 0)
}

func (s *Index_optionContext) AllSINGLE_QUOTE_SYMB() []antlr.TerminalNode {
	return s.GetTokens(CreateParserSINGLE_QUOTE_SYMB)
}

func (s *Index_optionContext) SINGLE_QUOTE_SYMB(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserSINGLE_QUOTE_SYMB, i)
}

func (s *Index_optionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Index_optionContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(CreateParserENGINE_ATTRIBUTE, 0)
}

func (s *Index_optionContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(CreateParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *Index_optionContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(CreateParserVISIBLE, 0)
}

func (s *Index_optionContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(CreateParserINVISIBLE, 0)
}

func (s *Index_optionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(CreateParserEQUAL_SYMBOL, 0)
}

func (s *Index_optionContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *Index_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterIndex_option(s)
	}
}

func (s *Index_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitIndex_option(s)
	}
}

func (p *CreateParser) Index_option() (localctx IIndex_optionContext) {
	localctx = NewIndex_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CreateParserRULE_index_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CreateParserKEY_BLOCK_SIZE:
		{
			p.SetState(190)
			p.Match(CreateParserKEY_BLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(191)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(192)
			p.Value()
		}

	case CreateParserUSING:
		{
			p.SetState(193)
			p.Index_type()
		}

	case CreateParserWITH:
		{
			p.SetState(194)
			p.Match(CreateParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(195)
			p.Match(CreateParserPARSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(196)
			p.Parser_name()
		}

	case CreateParserCOMMENT:
		{
			p.SetState(197)
			p.Match(CreateParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(198)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(199)
			p.String_()
		}
		{
			p.SetState(200)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CreateParserINVISIBLE, CreateParserVISIBLE:
		{
			p.SetState(202)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CreateParserINVISIBLE || _la == CreateParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case CreateParserENGINE_ATTRIBUTE:
		{
			p.SetState(203)
			p.Match(CreateParserENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(204)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(205)
			p.String_()
		}

	case CreateParserSECONDARY_ENGINE_ATTRIBUTE:
		{
			p.SetState(206)
			p.Match(CreateParserSECONDARY_ENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(207)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(208)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheck_constraint_definitionContext is an interface to support dynamic dispatch.
type ICheck_constraint_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	Expr() IExprContext
	RR_BRACKET() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	NOT() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode
	Symbol() ISymbolContext

	// IsCheck_constraint_definitionContext differentiates from other interfaces.
	IsCheck_constraint_definitionContext()
}

type Check_constraint_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheck_constraint_definitionContext() *Check_constraint_definitionContext {
	var p = new(Check_constraint_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_check_constraint_definition
	return p
}

func InitEmptyCheck_constraint_definitionContext(p *Check_constraint_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_check_constraint_definition
}

func (*Check_constraint_definitionContext) IsCheck_constraint_definitionContext() {}

func NewCheck_constraint_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Check_constraint_definitionContext {
	var p = new(Check_constraint_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_check_constraint_definition

	return p
}

func (s *Check_constraint_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Check_constraint_definitionContext) CHECK() antlr.TerminalNode {
	return s.GetToken(CreateParserCHECK, 0)
}

func (s *Check_constraint_definitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserLR_BRACKET, 0)
}

func (s *Check_constraint_definitionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Check_constraint_definitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserRR_BRACKET, 0)
}

func (s *Check_constraint_definitionContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CreateParserCONSTRAINT, 0)
}

func (s *Check_constraint_definitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(CreateParserNOT, 0)
}

func (s *Check_constraint_definitionContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(CreateParserENFORCED, 0)
}

func (s *Check_constraint_definitionContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Check_constraint_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Check_constraint_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Check_constraint_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterCheck_constraint_definition(s)
	}
}

func (s *Check_constraint_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitCheck_constraint_definition(s)
	}
}

func (p *CreateParser) Check_constraint_definition() (localctx ICheck_constraint_definitionContext) {
	localctx = NewCheck_constraint_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CreateParserRULE_check_constraint_definition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserCONSTRAINT {
		{
			p.SetState(211)
			p.Match(CreateParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserID {
			{
				p.SetState(212)
				p.Symbol()
			}

		}

	}
	{
		p.SetState(217)
		p.Match(CreateParserCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(218)
		p.Match(CreateParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(219)
		p.Expr()
	}
	{
		p.SetState(220)
		p.Match(CreateParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserNOT {
		{
			p.SetState(221)
			p.Match(CreateParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(222)
			p.Match(CreateParserENFORCED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReference_definitionContext is an interface to support dynamic dispatch.
type IReference_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFERENCES() antlr.TerminalNode
	Tbl_name() ITbl_nameContext
	LR_BRACKET() antlr.TerminalNode
	AllKey_part() []IKey_partContext
	Key_part(i int) IKey_partContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	MATCH() antlr.TerminalNode
	FULL() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	DELETE() antlr.TerminalNode
	AllReference_option() []IReference_optionContext
	Reference_option(i int) IReference_optionContext
	UPDATE() antlr.TerminalNode

	// IsReference_definitionContext differentiates from other interfaces.
	IsReference_definitionContext()
}

type Reference_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReference_definitionContext() *Reference_definitionContext {
	var p = new(Reference_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_reference_definition
	return p
}

func InitEmptyReference_definitionContext(p *Reference_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_reference_definition
}

func (*Reference_definitionContext) IsReference_definitionContext() {}

func NewReference_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reference_definitionContext {
	var p = new(Reference_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_reference_definition

	return p
}

func (s *Reference_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Reference_definitionContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(CreateParserREFERENCES, 0)
}

func (s *Reference_definitionContext) Tbl_name() ITbl_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITbl_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITbl_nameContext)
}

func (s *Reference_definitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserLR_BRACKET, 0)
}

func (s *Reference_definitionContext) AllKey_part() []IKey_partContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKey_partContext); ok {
			len++
		}
	}

	tst := make([]IKey_partContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKey_partContext); ok {
			tst[i] = t.(IKey_partContext)
			i++
		}
	}

	return tst
}

func (s *Reference_definitionContext) Key_part(i int) IKey_partContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKey_partContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKey_partContext)
}

func (s *Reference_definitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserRR_BRACKET, 0)
}

func (s *Reference_definitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CreateParserCOMMA)
}

func (s *Reference_definitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMA, i)
}

func (s *Reference_definitionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CreateParserMATCH, 0)
}

func (s *Reference_definitionContext) FULL() antlr.TerminalNode {
	return s.GetToken(CreateParserFULL, 0)
}

func (s *Reference_definitionContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(CreateParserPARTIAL, 0)
}

func (s *Reference_definitionContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(CreateParserSIMPLE, 0)
}

func (s *Reference_definitionContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(CreateParserON)
}

func (s *Reference_definitionContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserON, i)
}

func (s *Reference_definitionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CreateParserDELETE, 0)
}

func (s *Reference_definitionContext) AllReference_option() []IReference_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReference_optionContext); ok {
			len++
		}
	}

	tst := make([]IReference_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReference_optionContext); ok {
			tst[i] = t.(IReference_optionContext)
			i++
		}
	}

	return tst
}

func (s *Reference_definitionContext) Reference_option(i int) IReference_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReference_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReference_optionContext)
}

func (s *Reference_definitionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(CreateParserUPDATE, 0)
}

func (s *Reference_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reference_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reference_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterReference_definition(s)
	}
}

func (s *Reference_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitReference_definition(s)
	}
}

func (p *CreateParser) Reference_definition() (localctx IReference_definitionContext) {
	localctx = NewReference_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CreateParserRULE_reference_definition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(225)
		p.Match(CreateParserREFERENCES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(226)
		p.Tbl_name()
	}
	{
		p.SetState(227)
		p.Match(CreateParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(228)
		p.Key_part()
	}
	p.SetState(233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CreateParserCOMMA {
		{
			p.SetState(229)
			p.Match(CreateParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(230)
			p.Key_part()
		}

		p.SetState(235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(236)
		p.Match(CreateParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(243)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(237)
			p.Match(CreateParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(238)
			p.Match(CreateParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(239)
			p.Match(CreateParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(240)
			p.Match(CreateParserPARTIAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(241)
			p.Match(CreateParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(242)
			p.Match(CreateParserSIMPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(248)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(245)
			p.Match(CreateParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(246)
			p.Match(CreateParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(247)
			p.Reference_option()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserON {
		{
			p.SetState(250)
			p.Match(CreateParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(251)
			p.Match(CreateParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(252)
			p.Reference_option()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReference_optionContext is an interface to support dynamic dispatch.
type IReference_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	SET() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NO() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsReference_optionContext differentiates from other interfaces.
	IsReference_optionContext()
}

type Reference_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReference_optionContext() *Reference_optionContext {
	var p = new(Reference_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_reference_option
	return p
}

func InitEmptyReference_optionContext(p *Reference_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_reference_option
}

func (*Reference_optionContext) IsReference_optionContext() {}

func NewReference_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reference_optionContext {
	var p = new(Reference_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_reference_option

	return p
}

func (s *Reference_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Reference_optionContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(CreateParserRESTRICT, 0)
}

func (s *Reference_optionContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(CreateParserCASCADE, 0)
}

func (s *Reference_optionContext) SET() antlr.TerminalNode {
	return s.GetToken(CreateParserSET, 0)
}

func (s *Reference_optionContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CreateParserNULL_LITERAL, 0)
}

func (s *Reference_optionContext) NO() antlr.TerminalNode {
	return s.GetToken(CreateParserNO, 0)
}

func (s *Reference_optionContext) ACTION() antlr.TerminalNode {
	return s.GetToken(CreateParserACTION, 0)
}

func (s *Reference_optionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(CreateParserDEFAULT, 0)
}

func (s *Reference_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reference_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reference_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterReference_option(s)
	}
}

func (s *Reference_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitReference_option(s)
	}
}

func (p *CreateParser) Reference_option() (localctx IReference_optionContext) {
	localctx = NewReference_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CreateParserRULE_reference_option)
	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(255)
			p.Match(CreateParserRESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(256)
			p.Match(CreateParserCASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(257)
			p.Match(CreateParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(258)
			p.Match(CreateParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(259)
			p.Match(CreateParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(260)
			p.Match(CreateParserACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(261)
			p.Match(CreateParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(262)
			p.Match(CreateParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_optionsContext is an interface to support dynamic dispatch.
type ITable_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTable_option() []ITable_optionContext
	Table_option(i int) ITable_optionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTable_optionsContext differentiates from other interfaces.
	IsTable_optionsContext()
}

type Table_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_optionsContext() *Table_optionsContext {
	var p = new(Table_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_table_options
	return p
}

func InitEmptyTable_optionsContext(p *Table_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_table_options
}

func (*Table_optionsContext) IsTable_optionsContext() {}

func NewTable_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_optionsContext {
	var p = new(Table_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_table_options

	return p
}

func (s *Table_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_optionsContext) AllTable_option() []ITable_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_optionContext); ok {
			len++
		}
	}

	tst := make([]ITable_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_optionContext); ok {
			tst[i] = t.(ITable_optionContext)
			i++
		}
	}

	return tst
}

func (s *Table_optionsContext) Table_option(i int) ITable_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_optionContext)
}

func (s *Table_optionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CreateParserCOMMA)
}

func (s *Table_optionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMA, i)
}

func (s *Table_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterTable_options(s)
	}
}

func (s *Table_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitTable_options(s)
	}
}

func (p *CreateParser) Table_options() (localctx ITable_optionsContext) {
	localctx = NewTable_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CreateParserRULE_table_options)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(265)
		p.Table_option()
	}
	p.SetState(270)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CreateParserCOMMA {
		{
			p.SetState(266)
			p.Match(CreateParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(267)
			p.Table_option()
		}

		p.SetState(272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_optionContext is an interface to support dynamic dispatch.
type ITable_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AUTOEXTEND_SIZE() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	Value() IValueContext
	AUTO_INCREMENT() antlr.TerminalNode
	AVG_ROW_LENGTH() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	Charset_name() ICharset_nameContext
	DEFAULT() antlr.TerminalNode
	CHECKSUM() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	Collation_name() ICollation_nameContext
	COMMENT() antlr.TerminalNode
	AllSINGLE_QUOTE_SYMB() []antlr.TerminalNode
	SINGLE_QUOTE_SYMB(i int) antlr.TerminalNode
	String_() IStringContext
	CONNECTION() antlr.TerminalNode
	Connect_string() IConnect_stringContext
	DIRECTORY() antlr.TerminalNode
	DATA() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Absolute_path_to_directory() IAbsolute_path_to_directoryContext
	DELAY_KEY_WRITE() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	Engine_name() IEngine_nameContext
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	INSERT_METHOD() antlr.TerminalNode
	NO() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	KEY_BLOCK_SIZE() antlr.TerminalNode
	MAX_ROWS() antlr.TerminalNode
	MIN_ROWS() antlr.TerminalNode
	PACK_KEYS() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	ROW_FORMAT() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	FIXED() antlr.TerminalNode
	COMPRESSED() antlr.TerminalNode
	REDUNDANT() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode
	STATS_AUTO_RECALC() antlr.TerminalNode
	STATS_PERSISTENT() antlr.TerminalNode
	STATS_SAMPLE_PAGES() antlr.TerminalNode
	Tablespace_option() ITablespace_optionContext
	UNION() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllTbl_name() []ITbl_nameContext
	Tbl_name(i int) ITbl_nameContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTable_optionContext differentiates from other interfaces.
	IsTable_optionContext()
}

type Table_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_optionContext() *Table_optionContext {
	var p = new(Table_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_table_option
	return p
}

func InitEmptyTable_optionContext(p *Table_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_table_option
}

func (*Table_optionContext) IsTable_optionContext() {}

func NewTable_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_optionContext {
	var p = new(Table_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_table_option

	return p
}

func (s *Table_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_optionContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(CreateParserAUTOEXTEND_SIZE, 0)
}

func (s *Table_optionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(CreateParserEQUAL_SYMBOL, 0)
}

func (s *Table_optionContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *Table_optionContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(CreateParserAUTO_INCREMENT, 0)
}

func (s *Table_optionContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(CreateParserAVG_ROW_LENGTH, 0)
}

func (s *Table_optionContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(CreateParserCHARACTER, 0)
}

func (s *Table_optionContext) SET() antlr.TerminalNode {
	return s.GetToken(CreateParserSET, 0)
}

func (s *Table_optionContext) Charset_name() ICharset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_nameContext)
}

func (s *Table_optionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(CreateParserDEFAULT, 0)
}

func (s *Table_optionContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(CreateParserCHECKSUM, 0)
}

func (s *Table_optionContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(CreateParserZERO_DECIMAL, 0)
}

func (s *Table_optionContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(CreateParserONE_DECIMAL, 0)
}

func (s *Table_optionContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(CreateParserCOLLATE, 0)
}

func (s *Table_optionContext) Collation_name() ICollation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollation_nameContext)
}

func (s *Table_optionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMENT, 0)
}

func (s *Table_optionContext) AllSINGLE_QUOTE_SYMB() []antlr.TerminalNode {
	return s.GetTokens(CreateParserSINGLE_QUOTE_SYMB)
}

func (s *Table_optionContext) SINGLE_QUOTE_SYMB(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserSINGLE_QUOTE_SYMB, i)
}

func (s *Table_optionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Table_optionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(CreateParserCONNECTION, 0)
}

func (s *Table_optionContext) Connect_string() IConnect_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConnect_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConnect_stringContext)
}

func (s *Table_optionContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(CreateParserDIRECTORY, 0)
}

func (s *Table_optionContext) DATA() antlr.TerminalNode {
	return s.GetToken(CreateParserDATA, 0)
}

func (s *Table_optionContext) INDEX() antlr.TerminalNode {
	return s.GetToken(CreateParserINDEX, 0)
}

func (s *Table_optionContext) Absolute_path_to_directory() IAbsolute_path_to_directoryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbsolute_path_to_directoryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbsolute_path_to_directoryContext)
}

func (s *Table_optionContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(CreateParserDELAY_KEY_WRITE, 0)
}

func (s *Table_optionContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(CreateParserENGINE, 0)
}

func (s *Table_optionContext) Engine_name() IEngine_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngine_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngine_nameContext)
}

func (s *Table_optionContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(CreateParserENGINE_ATTRIBUTE, 0)
}

func (s *Table_optionContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(CreateParserINSERT_METHOD, 0)
}

func (s *Table_optionContext) NO() antlr.TerminalNode {
	return s.GetToken(CreateParserNO, 0)
}

func (s *Table_optionContext) FIRST() antlr.TerminalNode {
	return s.GetToken(CreateParserFIRST, 0)
}

func (s *Table_optionContext) LAST() antlr.TerminalNode {
	return s.GetToken(CreateParserLAST, 0)
}

func (s *Table_optionContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(CreateParserKEY_BLOCK_SIZE, 0)
}

func (s *Table_optionContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(CreateParserMAX_ROWS, 0)
}

func (s *Table_optionContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(CreateParserMIN_ROWS, 0)
}

func (s *Table_optionContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(CreateParserPACK_KEYS, 0)
}

func (s *Table_optionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(CreateParserPASSWORD, 0)
}

func (s *Table_optionContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(CreateParserROW_FORMAT, 0)
}

func (s *Table_optionContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(CreateParserDYNAMIC, 0)
}

func (s *Table_optionContext) FIXED() antlr.TerminalNode {
	return s.GetToken(CreateParserFIXED, 0)
}

func (s *Table_optionContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(CreateParserCOMPRESSED, 0)
}

func (s *Table_optionContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(CreateParserREDUNDANT, 0)
}

func (s *Table_optionContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(CreateParserCOMPACT, 0)
}

func (s *Table_optionContext) START() antlr.TerminalNode {
	return s.GetToken(CreateParserSTART, 0)
}

func (s *Table_optionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(CreateParserTRANSACTION, 0)
}

func (s *Table_optionContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(CreateParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *Table_optionContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(CreateParserSTATS_AUTO_RECALC, 0)
}

func (s *Table_optionContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(CreateParserSTATS_PERSISTENT, 0)
}

func (s *Table_optionContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(CreateParserSTATS_SAMPLE_PAGES, 0)
}

func (s *Table_optionContext) Tablespace_option() ITablespace_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespace_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespace_optionContext)
}

func (s *Table_optionContext) UNION() antlr.TerminalNode {
	return s.GetToken(CreateParserUNION, 0)
}

func (s *Table_optionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserLR_BRACKET, 0)
}

func (s *Table_optionContext) AllTbl_name() []ITbl_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITbl_nameContext); ok {
			len++
		}
	}

	tst := make([]ITbl_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITbl_nameContext); ok {
			tst[i] = t.(ITbl_nameContext)
			i++
		}
	}

	return tst
}

func (s *Table_optionContext) Tbl_name(i int) ITbl_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITbl_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITbl_nameContext)
}

func (s *Table_optionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CreateParserRR_BRACKET, 0)
}

func (s *Table_optionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CreateParserCOMMA)
}

func (s *Table_optionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMA, i)
}

func (s *Table_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterTable_option(s)
	}
}

func (s *Table_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitTable_option(s)
	}
}

func (p *CreateParser) Table_option() (localctx ITable_optionContext) {
	localctx = NewTable_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CreateParserRULE_table_option)
	var _la int

	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(273)
			p.Match(CreateParserAUTOEXTEND_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(274)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(275)
			p.Value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(276)
			p.Match(CreateParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(277)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(278)
			p.Value()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(279)
			p.Match(CreateParserAVG_ROW_LENGTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(280)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(281)
			p.Value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserDEFAULT {
			{
				p.SetState(282)
				p.Match(CreateParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(285)
			p.Match(CreateParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(286)
			p.Match(CreateParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(287)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(288)
			p.Charset_name()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(289)
			p.Match(CreateParserCHECKSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(290)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(291)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CreateParserZERO_DECIMAL || _la == CreateParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserDEFAULT {
			{
				p.SetState(292)
				p.Match(CreateParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(295)
			p.Match(CreateParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(296)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(297)
			p.Collation_name()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(298)
			p.Match(CreateParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserEQUAL_SYMBOL {
			{
				p.SetState(299)
				p.Match(CreateParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(302)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(303)
			p.String_()
		}
		{
			p.SetState(304)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(306)
			p.Match(CreateParserCONNECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(307)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(308)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(309)
			p.Connect_string()
		}
		{
			p.SetState(310)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(312)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CreateParserINDEX || _la == CreateParserDATA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(313)
			p.Match(CreateParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(314)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(315)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(316)
			p.Absolute_path_to_directory()
		}
		{
			p.SetState(317)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(319)
			p.Match(CreateParserDELAY_KEY_WRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(320)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(321)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CreateParserZERO_DECIMAL || _la == CreateParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(322)
			p.Match(CreateParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(323)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(324)
			p.Engine_name()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(325)
			p.Match(CreateParserENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(326)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(327)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(328)
			p.String_()
		}
		{
			p.SetState(329)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(331)
			p.Match(CreateParserINSERT_METHOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(332)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(333)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CreateParserFIRST || _la == CreateParserLAST || _la == CreateParserNO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(334)
			p.Match(CreateParserKEY_BLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(335)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(336)
			p.Value()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(337)
			p.Match(CreateParserMAX_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(338)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(339)
			p.Value()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(340)
			p.Match(CreateParserMIN_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(341)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(342)
			p.Value()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(343)
			p.Match(CreateParserPACK_KEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(344)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(345)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CreateParserDEFAULT || _la == CreateParserZERO_DECIMAL || _la == CreateParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(346)
			p.Match(CreateParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(347)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(348)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(349)
			p.String_()
		}
		{
			p.SetState(350)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(352)
			p.Match(CreateParserROW_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(353)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(354)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CreateParserDEFAULT || ((int64((_la-370)) & ^0x3f) == 0 && ((int64(1)<<(_la-370))&2305843013508661253) != 0) || _la == CreateParserREDUNDANT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(355)
			p.Match(CreateParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(356)
			p.Match(CreateParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(357)
			p.Match(CreateParserSECONDARY_ENGINE_ATTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(358)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(359)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(360)
			p.String_()
		}
		{
			p.SetState(361)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(363)
			p.Match(CreateParserSTATS_AUTO_RECALC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(364)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(365)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CreateParserDEFAULT || _la == CreateParserZERO_DECIMAL || _la == CreateParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(366)
			p.Match(CreateParserSTATS_PERSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(367)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(368)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CreateParserDEFAULT || _la == CreateParserZERO_DECIMAL || _la == CreateParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(369)
			p.Match(CreateParserSTATS_SAMPLE_PAGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(370)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(371)
			p.Value()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(372)
			p.Tablespace_option()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(373)
			p.Match(CreateParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(374)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(375)
			p.Match(CreateParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(376)
			p.Tbl_name()
		}
		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CreateParserCOMMA {
			{
				p.SetState(377)
				p.Match(CreateParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(378)
				p.Tbl_name()
			}

			p.SetState(383)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(384)
			p.Match(CreateParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartition_optionsContext is an interface to support dynamic dispatch.
type IPartition_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	AllHASH() []antlr.TerminalNode
	HASH(i int) antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllKEY() []antlr.TerminalNode
	KEY(i int) antlr.TerminalNode
	AllColumn_list() []IColumn_listContext
	Column_list(i int) IColumn_listContext
	RANGE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	LIST() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	AllNum() []INumContext
	Num(i int) INumContext
	SUBPARTITION() antlr.TerminalNode
	AllPartition_definition() []IPartition_definitionContext
	Partition_definition(i int) IPartition_definitionContext
	AllLINEAR() []antlr.TerminalNode
	LINEAR(i int) antlr.TerminalNode
	AllALGORITHM() []antlr.TerminalNode
	ALGORITHM(i int) antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllONE_DECIMAL() []antlr.TerminalNode
	ONE_DECIMAL(i int) antlr.TerminalNode
	AllTWO_DECIMAL() []antlr.TerminalNode
	TWO_DECIMAL(i int) antlr.TerminalNode
	SUBPARTITIONS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartition_optionsContext differentiates from other interfaces.
	IsPartition_optionsContext()
}

type Partition_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_optionsContext() *Partition_optionsContext {
	var p = new(Partition_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_partition_options
	return p
}

func InitEmptyPartition_optionsContext(p *Partition_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_partition_options
}

func (*Partition_optionsContext) IsPartition_optionsContext() {}

func NewPartition_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_optionsContext {
	var p = new(Partition_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_partition_options

	return p
}

func (s *Partition_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_optionsContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(CreateParserPARTITION, 0)
}

func (s *Partition_optionsContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(CreateParserBY)
}

func (s *Partition_optionsContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserBY, i)
}

func (s *Partition_optionsContext) AllHASH() []antlr.TerminalNode {
	return s.GetTokens(CreateParserHASH)
}

func (s *Partition_optionsContext) HASH(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserHASH, i)
}

func (s *Partition_optionsContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(CreateParserLR_BRACKET)
}

func (s *Partition_optionsContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserLR_BRACKET, i)
}

func (s *Partition_optionsContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Partition_optionsContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Partition_optionsContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(CreateParserRR_BRACKET)
}

func (s *Partition_optionsContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserRR_BRACKET, i)
}

func (s *Partition_optionsContext) AllKEY() []antlr.TerminalNode {
	return s.GetTokens(CreateParserKEY)
}

func (s *Partition_optionsContext) KEY(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserKEY, i)
}

func (s *Partition_optionsContext) AllColumn_list() []IColumn_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_listContext); ok {
			len++
		}
	}

	tst := make([]IColumn_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_listContext); ok {
			tst[i] = t.(IColumn_listContext)
			i++
		}
	}

	return tst
}

func (s *Partition_optionsContext) Column_list(i int) IColumn_listContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_listContext)
}

func (s *Partition_optionsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(CreateParserRANGE, 0)
}

func (s *Partition_optionsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(CreateParserCOLUMNS, 0)
}

func (s *Partition_optionsContext) LIST() antlr.TerminalNode {
	return s.GetToken(CreateParserLIST, 0)
}

func (s *Partition_optionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(CreateParserPARTITIONS, 0)
}

func (s *Partition_optionsContext) AllNum() []INumContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumContext); ok {
			len++
		}
	}

	tst := make([]INumContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumContext); ok {
			tst[i] = t.(INumContext)
			i++
		}
	}

	return tst
}

func (s *Partition_optionsContext) Num(i int) INumContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumContext)
}

func (s *Partition_optionsContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(CreateParserSUBPARTITION, 0)
}

func (s *Partition_optionsContext) AllPartition_definition() []IPartition_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartition_definitionContext); ok {
			len++
		}
	}

	tst := make([]IPartition_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartition_definitionContext); ok {
			tst[i] = t.(IPartition_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Partition_optionsContext) Partition_definition(i int) IPartition_definitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_definitionContext)
}

func (s *Partition_optionsContext) AllLINEAR() []antlr.TerminalNode {
	return s.GetTokens(CreateParserLINEAR)
}

func (s *Partition_optionsContext) LINEAR(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserLINEAR, i)
}

func (s *Partition_optionsContext) AllALGORITHM() []antlr.TerminalNode {
	return s.GetTokens(CreateParserALGORITHM)
}

func (s *Partition_optionsContext) ALGORITHM(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserALGORITHM, i)
}

func (s *Partition_optionsContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(CreateParserEQUAL_SYMBOL)
}

func (s *Partition_optionsContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserEQUAL_SYMBOL, i)
}

func (s *Partition_optionsContext) AllONE_DECIMAL() []antlr.TerminalNode {
	return s.GetTokens(CreateParserONE_DECIMAL)
}

func (s *Partition_optionsContext) ONE_DECIMAL(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserONE_DECIMAL, i)
}

func (s *Partition_optionsContext) AllTWO_DECIMAL() []antlr.TerminalNode {
	return s.GetTokens(CreateParserTWO_DECIMAL)
}

func (s *Partition_optionsContext) TWO_DECIMAL(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserTWO_DECIMAL, i)
}

func (s *Partition_optionsContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(CreateParserSUBPARTITIONS, 0)
}

func (s *Partition_optionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CreateParserCOMMA)
}

func (s *Partition_optionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMA, i)
}

func (s *Partition_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterPartition_options(s)
	}
}

func (s *Partition_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitPartition_options(s)
	}
}

func (p *CreateParser) Partition_options() (localctx IPartition_optionsContext) {
	localctx = NewPartition_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CreateParserRULE_partition_options)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(388)
		p.Match(CreateParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(389)
		p.Match(CreateParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserLINEAR {
			{
				p.SetState(390)
				p.Match(CreateParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(393)
			p.Match(CreateParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(394)
			p.Match(CreateParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(395)
			p.Expr()
		}
		{
			p.SetState(396)
			p.Match(CreateParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserLINEAR {
			{
				p.SetState(398)
				p.Match(CreateParserLINEAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(401)
			p.Match(CreateParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserALGORITHM {
			{
				p.SetState(402)
				p.Match(CreateParserALGORITHM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(403)
				p.Match(CreateParserEQUAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(404)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CreateParserONE_DECIMAL || _la == CreateParserTWO_DECIMAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(407)
			p.Match(CreateParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(408)
			p.Column_list()
		}
		{
			p.SetState(409)
			p.Match(CreateParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(411)
			p.Match(CreateParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserLR_BRACKET {
			{
				p.SetState(412)
				p.Match(CreateParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(413)
				p.Expr()
			}
			{
				p.SetState(414)
				p.Match(CreateParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(418)
			p.Match(CreateParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(419)
			p.Match(CreateParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(420)
			p.Column_list()
		}
		{
			p.SetState(421)
			p.Match(CreateParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(423)
			p.Match(CreateParserLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserLR_BRACKET {
			{
				p.SetState(424)
				p.Match(CreateParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(425)
				p.Expr()
			}
			{
				p.SetState(426)
				p.Match(CreateParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(430)
			p.Match(CreateParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(431)
			p.Match(CreateParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(432)
			p.Column_list()
		}
		{
			p.SetState(433)
			p.Match(CreateParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserPARTITIONS {
		{
			p.SetState(437)
			p.Match(CreateParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(438)
			p.Num()
		}

	}
	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserSUBPARTITION {
		{
			p.SetState(441)
			p.Match(CreateParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(442)
			p.Match(CreateParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
		case 1:
			p.SetState(444)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CreateParserLINEAR {
				{
					p.SetState(443)
					p.Match(CreateParserLINEAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(446)
				p.Match(CreateParserHASH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(447)
				p.Match(CreateParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(448)
				p.Expr()
			}
			{
				p.SetState(449)
				p.Match(CreateParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			p.SetState(452)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CreateParserLINEAR {
				{
					p.SetState(451)
					p.Match(CreateParserLINEAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(454)
				p.Match(CreateParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(458)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CreateParserALGORITHM {
				{
					p.SetState(455)
					p.Match(CreateParserALGORITHM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(456)
					p.Match(CreateParserEQUAL_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(457)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CreateParserONE_DECIMAL || _la == CreateParserTWO_DECIMAL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(460)
				p.Match(CreateParserLR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(461)
				p.Column_list()
			}
			{
				p.SetState(462)
				p.Match(CreateParserRR_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserSUBPARTITIONS {
			{
				p.SetState(466)
				p.Match(CreateParserSUBPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(467)
				p.Num()
			}

		}

	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserLR_BRACKET {
		{
			p.SetState(472)
			p.Match(CreateParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(473)
			p.Partition_definition()
		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CreateParserCOMMA {
			{
				p.SetState(474)
				p.Match(CreateParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(475)
				p.Partition_definition()
			}

			p.SetState(480)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(481)
			p.Match(CreateParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartition_definitionContext is an interface to support dynamic dispatch.
type IPartition_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Partition_name() IPartition_nameContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	Value_list() IValue_listContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	AllDIRECTORY() []antlr.TerminalNode
	DIRECTORY(i int) antlr.TerminalNode
	INDEX() antlr.TerminalNode
	MAX_ROWS() antlr.TerminalNode
	MIN_ROWS() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	AllSubpartition_definition() []ISubpartition_definitionContext
	Subpartition_definition(i int) ISubpartition_definitionContext
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	Engine_name() IEngine_nameContext
	AllSINGLE_QUOTE_SYMB() []antlr.TerminalNode
	SINGLE_QUOTE_SYMB(i int) antlr.TerminalNode
	String_() IStringContext
	Data_dir() IData_dirContext
	Index_dir() IIndex_dirContext
	Max_number_of_rows() IMax_number_of_rowsContext
	Min_number_of_rows() IMin_number_of_rowsContext
	Tablespace_name() ITablespace_nameContext
	STORAGE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	Expr() IExprContext

	// IsPartition_definitionContext differentiates from other interfaces.
	IsPartition_definitionContext()
}

type Partition_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_definitionContext() *Partition_definitionContext {
	var p = new(Partition_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_partition_definition
	return p
}

func InitEmptyPartition_definitionContext(p *Partition_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_partition_definition
}

func (*Partition_definitionContext) IsPartition_definitionContext() {}

func NewPartition_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_definitionContext {
	var p = new(Partition_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_partition_definition

	return p
}

func (s *Partition_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_definitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(CreateParserPARTITION, 0)
}

func (s *Partition_definitionContext) Partition_name() IPartition_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_nameContext)
}

func (s *Partition_definitionContext) VALUES() antlr.TerminalNode {
	return s.GetToken(CreateParserVALUES, 0)
}

func (s *Partition_definitionContext) IN() antlr.TerminalNode {
	return s.GetToken(CreateParserIN, 0)
}

func (s *Partition_definitionContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(CreateParserLR_BRACKET)
}

func (s *Partition_definitionContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserLR_BRACKET, i)
}

func (s *Partition_definitionContext) Value_list() IValue_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValue_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValue_listContext)
}

func (s *Partition_definitionContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(CreateParserRR_BRACKET)
}

func (s *Partition_definitionContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserRR_BRACKET, i)
}

func (s *Partition_definitionContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(CreateParserENGINE, 0)
}

func (s *Partition_definitionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMENT, 0)
}

func (s *Partition_definitionContext) DATA() antlr.TerminalNode {
	return s.GetToken(CreateParserDATA, 0)
}

func (s *Partition_definitionContext) AllDIRECTORY() []antlr.TerminalNode {
	return s.GetTokens(CreateParserDIRECTORY)
}

func (s *Partition_definitionContext) DIRECTORY(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserDIRECTORY, i)
}

func (s *Partition_definitionContext) INDEX() antlr.TerminalNode {
	return s.GetToken(CreateParserINDEX, 0)
}

func (s *Partition_definitionContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(CreateParserMAX_ROWS, 0)
}

func (s *Partition_definitionContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(CreateParserMIN_ROWS, 0)
}

func (s *Partition_definitionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(CreateParserTABLESPACE, 0)
}

func (s *Partition_definitionContext) AllSubpartition_definition() []ISubpartition_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartition_definitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartition_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartition_definitionContext); ok {
			tst[i] = t.(ISubpartition_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Partition_definitionContext) Subpartition_definition(i int) ISubpartition_definitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartition_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartition_definitionContext)
}

func (s *Partition_definitionContext) LESS() antlr.TerminalNode {
	return s.GetToken(CreateParserLESS, 0)
}

func (s *Partition_definitionContext) THAN() antlr.TerminalNode {
	return s.GetToken(CreateParserTHAN, 0)
}

func (s *Partition_definitionContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(CreateParserEQUAL_SYMBOL)
}

func (s *Partition_definitionContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserEQUAL_SYMBOL, i)
}

func (s *Partition_definitionContext) Engine_name() IEngine_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngine_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngine_nameContext)
}

func (s *Partition_definitionContext) AllSINGLE_QUOTE_SYMB() []antlr.TerminalNode {
	return s.GetTokens(CreateParserSINGLE_QUOTE_SYMB)
}

func (s *Partition_definitionContext) SINGLE_QUOTE_SYMB(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserSINGLE_QUOTE_SYMB, i)
}

func (s *Partition_definitionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Partition_definitionContext) Data_dir() IData_dirContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IData_dirContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IData_dirContext)
}

func (s *Partition_definitionContext) Index_dir() IIndex_dirContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_dirContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_dirContext)
}

func (s *Partition_definitionContext) Max_number_of_rows() IMax_number_of_rowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMax_number_of_rowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMax_number_of_rowsContext)
}

func (s *Partition_definitionContext) Min_number_of_rows() IMin_number_of_rowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMin_number_of_rowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMin_number_of_rowsContext)
}

func (s *Partition_definitionContext) Tablespace_name() ITablespace_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespace_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespace_nameContext)
}

func (s *Partition_definitionContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(CreateParserSTORAGE, 0)
}

func (s *Partition_definitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CreateParserCOMMA)
}

func (s *Partition_definitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMA, i)
}

func (s *Partition_definitionContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(CreateParserMAXVALUE, 0)
}

func (s *Partition_definitionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Partition_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterPartition_definition(s)
	}
}

func (s *Partition_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitPartition_definition(s)
	}
}

func (p *CreateParser) Partition_definition() (localctx IPartition_definitionContext) {
	localctx = NewPartition_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CreateParserRULE_partition_definition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(CreateParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(486)
		p.Partition_name()
	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case CreateParserVALUES:
		{
			p.SetState(487)
			p.Match(CreateParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(488)
			p.Match(CreateParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(489)
			p.Match(CreateParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CreateParserLR_BRACKET, CreateParserID:
			p.SetState(495)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case CreateParserLR_BRACKET:
				{
					p.SetState(490)
					p.Match(CreateParserLR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(491)
					p.Expr()
				}
				{
					p.SetState(492)
					p.Match(CreateParserRR_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case CreateParserID:
				{
					p.SetState(494)
					p.Value_list()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		case CreateParserMAXVALUE:
			{
				p.SetState(497)
				p.Match(CreateParserMAXVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case CreateParserIN:
		{
			p.SetState(500)
			p.Match(CreateParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.Match(CreateParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(502)
			p.Value_list()
		}
		{
			p.SetState(503)
			p.Match(CreateParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CreateParserINDEX, CreateParserCOMMENT, CreateParserDATA, CreateParserENGINE, CreateParserMAX_ROWS, CreateParserMIN_ROWS, CreateParserSTORAGE, CreateParserTABLESPACE, CreateParserLR_BRACKET, CreateParserRR_BRACKET, CreateParserCOMMA:

	default:
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserENGINE || _la == CreateParserSTORAGE {
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserSTORAGE {
			{
				p.SetState(507)
				p.Match(CreateParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(510)
			p.Match(CreateParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(511)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(512)
			p.Engine_name()
		}

	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserCOMMENT {
		{
			p.SetState(515)
			p.Match(CreateParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(516)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(517)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(518)
			p.String_()
		}
		{
			p.SetState(519)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserDATA {
		{
			p.SetState(523)
			p.Match(CreateParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(524)
			p.Match(CreateParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(525)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(526)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(527)
			p.Data_dir()
		}
		{
			p.SetState(528)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserINDEX {
		{
			p.SetState(532)
			p.Match(CreateParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(533)
			p.Match(CreateParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(534)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(535)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(536)
			p.Index_dir()
		}
		{
			p.SetState(537)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserMAX_ROWS {
		{
			p.SetState(541)
			p.Match(CreateParserMAX_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(542)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(543)
			p.Max_number_of_rows()
		}

	}
	p.SetState(549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserMIN_ROWS {
		{
			p.SetState(546)
			p.Match(CreateParserMIN_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(547)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(548)
			p.Min_number_of_rows()
		}

	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserTABLESPACE {
		{
			p.SetState(551)
			p.Match(CreateParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(552)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(553)
			p.Tablespace_name()
		}

	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserLR_BRACKET {
		{
			p.SetState(556)
			p.Match(CreateParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(557)
			p.Subpartition_definition()
		}
		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CreateParserCOMMA {
			{
				p.SetState(558)
				p.Match(CreateParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(559)
				p.Subpartition_definition()
			}

			p.SetState(564)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(565)
			p.Match(CreateParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpartition_definitionContext is an interface to support dynamic dispatch.
type ISubpartition_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION() antlr.TerminalNode
	Logical_name() ILogical_nameContext
	ENGINE() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	AllDIRECTORY() []antlr.TerminalNode
	DIRECTORY(i int) antlr.TerminalNode
	INDEX() antlr.TerminalNode
	MAX_ROWS() antlr.TerminalNode
	MIN_ROWS() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	Engine_name() IEngine_nameContext
	AllSINGLE_QUOTE_SYMB() []antlr.TerminalNode
	SINGLE_QUOTE_SYMB(i int) antlr.TerminalNode
	String_() IStringContext
	Data_dir() IData_dirContext
	Index_dir() IIndex_dirContext
	Max_number_of_rows() IMax_number_of_rowsContext
	Min_number_of_rows() IMin_number_of_rowsContext
	Tablespace_name() ITablespace_nameContext
	STORAGE() antlr.TerminalNode

	// IsSubpartition_definitionContext differentiates from other interfaces.
	IsSubpartition_definitionContext()
}

type Subpartition_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartition_definitionContext() *Subpartition_definitionContext {
	var p = new(Subpartition_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_subpartition_definition
	return p
}

func InitEmptySubpartition_definitionContext(p *Subpartition_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_subpartition_definition
}

func (*Subpartition_definitionContext) IsSubpartition_definitionContext() {}

func NewSubpartition_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subpartition_definitionContext {
	var p = new(Subpartition_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_subpartition_definition

	return p
}

func (s *Subpartition_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Subpartition_definitionContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(CreateParserSUBPARTITION, 0)
}

func (s *Subpartition_definitionContext) Logical_name() ILogical_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogical_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogical_nameContext)
}

func (s *Subpartition_definitionContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(CreateParserENGINE, 0)
}

func (s *Subpartition_definitionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMENT, 0)
}

func (s *Subpartition_definitionContext) DATA() antlr.TerminalNode {
	return s.GetToken(CreateParserDATA, 0)
}

func (s *Subpartition_definitionContext) AllDIRECTORY() []antlr.TerminalNode {
	return s.GetTokens(CreateParserDIRECTORY)
}

func (s *Subpartition_definitionContext) DIRECTORY(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserDIRECTORY, i)
}

func (s *Subpartition_definitionContext) INDEX() antlr.TerminalNode {
	return s.GetToken(CreateParserINDEX, 0)
}

func (s *Subpartition_definitionContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(CreateParserMAX_ROWS, 0)
}

func (s *Subpartition_definitionContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(CreateParserMIN_ROWS, 0)
}

func (s *Subpartition_definitionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(CreateParserTABLESPACE, 0)
}

func (s *Subpartition_definitionContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(CreateParserEQUAL_SYMBOL)
}

func (s *Subpartition_definitionContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserEQUAL_SYMBOL, i)
}

func (s *Subpartition_definitionContext) Engine_name() IEngine_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngine_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngine_nameContext)
}

func (s *Subpartition_definitionContext) AllSINGLE_QUOTE_SYMB() []antlr.TerminalNode {
	return s.GetTokens(CreateParserSINGLE_QUOTE_SYMB)
}

func (s *Subpartition_definitionContext) SINGLE_QUOTE_SYMB(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserSINGLE_QUOTE_SYMB, i)
}

func (s *Subpartition_definitionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Subpartition_definitionContext) Data_dir() IData_dirContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IData_dirContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IData_dirContext)
}

func (s *Subpartition_definitionContext) Index_dir() IIndex_dirContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_dirContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_dirContext)
}

func (s *Subpartition_definitionContext) Max_number_of_rows() IMax_number_of_rowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMax_number_of_rowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMax_number_of_rowsContext)
}

func (s *Subpartition_definitionContext) Min_number_of_rows() IMin_number_of_rowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMin_number_of_rowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMin_number_of_rowsContext)
}

func (s *Subpartition_definitionContext) Tablespace_name() ITablespace_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespace_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespace_nameContext)
}

func (s *Subpartition_definitionContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(CreateParserSTORAGE, 0)
}

func (s *Subpartition_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subpartition_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subpartition_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterSubpartition_definition(s)
	}
}

func (s *Subpartition_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitSubpartition_definition(s)
	}
}

func (p *CreateParser) Subpartition_definition() (localctx ISubpartition_definitionContext) {
	localctx = NewSubpartition_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CreateParserRULE_subpartition_definition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(569)
		p.Match(CreateParserSUBPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(570)
		p.Logical_name()
	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserENGINE || _la == CreateParserSTORAGE {
		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserSTORAGE {
			{
				p.SetState(571)
				p.Match(CreateParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(574)
			p.Match(CreateParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(575)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(576)
			p.Engine_name()
		}

	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserCOMMENT {
		{
			p.SetState(579)
			p.Match(CreateParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(580)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(581)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(582)
			p.String_()
		}
		{
			p.SetState(583)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserDATA {
		{
			p.SetState(587)
			p.Match(CreateParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(588)
			p.Match(CreateParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(589)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(590)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(591)
			p.Data_dir()
		}
		{
			p.SetState(592)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserINDEX {
		{
			p.SetState(596)
			p.Match(CreateParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(597)
			p.Match(CreateParserDIRECTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(598)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(599)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(600)
			p.Index_dir()
		}
		{
			p.SetState(601)
			p.Match(CreateParserSINGLE_QUOTE_SYMB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserMAX_ROWS {
		{
			p.SetState(605)
			p.Match(CreateParserMAX_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(606)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(607)
			p.Max_number_of_rows()
		}

	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserMIN_ROWS {
		{
			p.SetState(610)
			p.Match(CreateParserMIN_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(611)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)
			p.Min_number_of_rows()
		}

	}
	p.SetState(618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CreateParserTABLESPACE {
		{
			p.SetState(615)
			p.Match(CreateParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(616)
			p.Match(CreateParserEQUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(617)
			p.Tablespace_name()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespace_optionContext is an interface to support dynamic dispatch.
type ITablespace_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESPACE() antlr.TerminalNode
	Tablespace_name() ITablespace_nameContext
	STORAGE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	MEMORY() antlr.TerminalNode

	// IsTablespace_optionContext differentiates from other interfaces.
	IsTablespace_optionContext()
}

type Tablespace_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespace_optionContext() *Tablespace_optionContext {
	var p = new(Tablespace_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_tablespace_option
	return p
}

func InitEmptyTablespace_optionContext(p *Tablespace_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_tablespace_option
}

func (*Tablespace_optionContext) IsTablespace_optionContext() {}

func NewTablespace_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tablespace_optionContext {
	var p = new(Tablespace_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_tablespace_option

	return p
}

func (s *Tablespace_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tablespace_optionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(CreateParserTABLESPACE, 0)
}

func (s *Tablespace_optionContext) Tablespace_name() ITablespace_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespace_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespace_nameContext)
}

func (s *Tablespace_optionContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(CreateParserSTORAGE, 0)
}

func (s *Tablespace_optionContext) DISK() antlr.TerminalNode {
	return s.GetToken(CreateParserDISK, 0)
}

func (s *Tablespace_optionContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(CreateParserMEMORY, 0)
}

func (s *Tablespace_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tablespace_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tablespace_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterTablespace_option(s)
	}
}

func (s *Tablespace_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitTablespace_option(s)
	}
}

func (p *CreateParser) Tablespace_option() (localctx ITablespace_optionContext) {
	localctx = NewTablespace_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CreateParserRULE_tablespace_option)
	var _la int

	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(620)
			p.Match(CreateParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(621)
			p.Tablespace_name()
		}

		{
			p.SetState(622)
			p.Match(CreateParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(623)
			p.Match(CreateParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(627)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CreateParserTABLESPACE {
			{
				p.SetState(625)
				p.Match(CreateParserTABLESPACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(626)
				p.Tablespace_name()
			}

		}
		{
			p.SetState(629)
			p.Match(CreateParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(630)
			p.Match(CreateParserMEMORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITbl_nameContext is an interface to support dynamic dispatch.
type ITbl_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsTbl_nameContext differentiates from other interfaces.
	IsTbl_nameContext()
}

type Tbl_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTbl_nameContext() *Tbl_nameContext {
	var p = new(Tbl_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_tbl_name
	return p
}

func InitEmptyTbl_nameContext(p *Tbl_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_tbl_name
}

func (*Tbl_nameContext) IsTbl_nameContext() {}

func NewTbl_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tbl_nameContext {
	var p = new(Tbl_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_tbl_name

	return p
}

func (s *Tbl_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Tbl_nameContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Tbl_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tbl_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tbl_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterTbl_name(s)
	}
}

func (s *Tbl_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitTbl_name(s)
	}
}

func (p *CreateParser) Tbl_name() (localctx ITbl_nameContext) {
	localctx = NewTbl_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CreateParserRULE_tbl_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICol_nameContext is an interface to support dynamic dispatch.
type ICol_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsCol_nameContext differentiates from other interfaces.
	IsCol_nameContext()
}

type Col_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCol_nameContext() *Col_nameContext {
	var p = new(Col_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_col_name
	return p
}

func InitEmptyCol_nameContext(p *Col_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_col_name
}

func (*Col_nameContext) IsCol_nameContext() {}

func NewCol_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Col_nameContext {
	var p = new(Col_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_col_name

	return p
}

func (s *Col_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Col_nameContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Col_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Col_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Col_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterCol_name(s)
	}
}

func (s *Col_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitCol_name(s)
	}
}

func (p *CreateParser) Col_name() (localctx ICol_nameContext) {
	localctx = NewCol_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CreateParserRULE_col_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespace_nameContext is an interface to support dynamic dispatch.
type ITablespace_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsTablespace_nameContext differentiates from other interfaces.
	IsTablespace_nameContext()
}

type Tablespace_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespace_nameContext() *Tablespace_nameContext {
	var p = new(Tablespace_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_tablespace_name
	return p
}

func InitEmptyTablespace_nameContext(p *Tablespace_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_tablespace_name
}

func (*Tablespace_nameContext) IsTablespace_nameContext() {}

func NewTablespace_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tablespace_nameContext {
	var p = new(Tablespace_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_tablespace_name

	return p
}

func (s *Tablespace_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Tablespace_nameContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Tablespace_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tablespace_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tablespace_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterTablespace_name(s)
	}
}

func (s *Tablespace_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitTablespace_name(s)
	}
}

func (p *CreateParser) Tablespace_name() (localctx ITablespace_nameContext) {
	localctx = NewTablespace_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CreateParserRULE_tablespace_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_nameContext is an interface to support dynamic dispatch.
type IIndex_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsIndex_nameContext differentiates from other interfaces.
	IsIndex_nameContext()
}

type Index_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_nameContext() *Index_nameContext {
	var p = new(Index_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_index_name
	return p
}

func InitEmptyIndex_nameContext(p *Index_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_index_name
}

func (*Index_nameContext) IsIndex_nameContext() {}

func NewIndex_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_nameContext {
	var p = new(Index_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_index_name

	return p
}

func (s *Index_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_nameContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Index_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterIndex_name(s)
	}
}

func (s *Index_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitIndex_name(s)
	}
}

func (p *CreateParser) Index_name() (localctx IIndex_nameContext) {
	localctx = NewIndex_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CreateParserRULE_index_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngine_nameContext is an interface to support dynamic dispatch.
type IEngine_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARCHIVE() antlr.TerminalNode
	BLACKHOLE() antlr.TerminalNode
	CSV() antlr.TerminalNode
	FEDERATED() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MRG_MYISAM() antlr.TerminalNode
	MYISAM() antlr.TerminalNode
	NDB() antlr.TerminalNode
	NDBCLUSTER() antlr.TerminalNode
	PERFORMANCE_SCHEMA() antlr.TerminalNode
	TOKUDB() antlr.TerminalNode

	// IsEngine_nameContext differentiates from other interfaces.
	IsEngine_nameContext()
}

type Engine_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngine_nameContext() *Engine_nameContext {
	var p = new(Engine_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_engine_name
	return p
}

func InitEmptyEngine_nameContext(p *Engine_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_engine_name
}

func (*Engine_nameContext) IsEngine_nameContext() {}

func NewEngine_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Engine_nameContext {
	var p = new(Engine_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_engine_name

	return p
}

func (s *Engine_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Engine_nameContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(CreateParserARCHIVE, 0)
}

func (s *Engine_nameContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(CreateParserBLACKHOLE, 0)
}

func (s *Engine_nameContext) CSV() antlr.TerminalNode {
	return s.GetToken(CreateParserCSV, 0)
}

func (s *Engine_nameContext) FEDERATED() antlr.TerminalNode {
	return s.GetToken(CreateParserFEDERATED, 0)
}

func (s *Engine_nameContext) INNODB() antlr.TerminalNode {
	return s.GetToken(CreateParserINNODB, 0)
}

func (s *Engine_nameContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(CreateParserMEMORY, 0)
}

func (s *Engine_nameContext) MRG_MYISAM() antlr.TerminalNode {
	return s.GetToken(CreateParserMRG_MYISAM, 0)
}

func (s *Engine_nameContext) MYISAM() antlr.TerminalNode {
	return s.GetToken(CreateParserMYISAM, 0)
}

func (s *Engine_nameContext) NDB() antlr.TerminalNode {
	return s.GetToken(CreateParserNDB, 0)
}

func (s *Engine_nameContext) NDBCLUSTER() antlr.TerminalNode {
	return s.GetToken(CreateParserNDBCLUSTER, 0)
}

func (s *Engine_nameContext) PERFORMANCE_SCHEMA() antlr.TerminalNode {
	return s.GetToken(CreateParserPERFORMANCE_SCHEMA, 0)
}

func (s *Engine_nameContext) TOKUDB() antlr.TerminalNode {
	return s.GetToken(CreateParserTOKUDB, 0)
}

func (s *Engine_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Engine_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Engine_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterEngine_name(s)
	}
}

func (s *Engine_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitEngine_name(s)
	}
}

func (p *CreateParser) Engine_name() (localctx IEngine_nameContext) {
	localctx = NewEngine_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CreateParserRULE_engine_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-787)) & ^0x3f) == 0 && ((int64(1)<<(_la-787))&4095) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISymbolContext is an interface to support dynamic dispatch.
type ISymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsSymbolContext differentiates from other interfaces.
	IsSymbolContext()
}

type SymbolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolContext() *SymbolContext {
	var p = new(SymbolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_symbol
	return p
}

func InitEmptySymbolContext(p *SymbolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_symbol
}

func (*SymbolContext) IsSymbolContext() {}

func NewSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolContext {
	var p = new(SymbolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_symbol

	return p
}

func (s *SymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *SymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterSymbol(s)
	}
}

func (s *SymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitSymbol(s)
	}
}

func (p *CreateParser) Symbol() (localctx ISymbolContext) {
	localctx = NewSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CreateParserRULE_symbol)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(643)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *CreateParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CreateParserRULE_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(645)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitString(s)
	}
}

func (p *CreateParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CreateParserRULE_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollation_nameContext is an interface to support dynamic dispatch.
type ICollation_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsCollation_nameContext differentiates from other interfaces.
	IsCollation_nameContext()
}

type Collation_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollation_nameContext() *Collation_nameContext {
	var p = new(Collation_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_collation_name
	return p
}

func InitEmptyCollation_nameContext(p *Collation_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_collation_name
}

func (*Collation_nameContext) IsCollation_nameContext() {}

func NewCollation_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collation_nameContext {
	var p = new(Collation_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_collation_name

	return p
}

func (s *Collation_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Collation_nameContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Collation_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collation_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collation_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterCollation_name(s)
	}
}

func (s *Collation_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitCollation_name(s)
	}
}

func (p *CreateParser) Collation_name() (localctx ICollation_nameContext) {
	localctx = NewCollation_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CreateParserRULE_collation_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(649)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParser_nameContext is an interface to support dynamic dispatch.
type IParser_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsParser_nameContext differentiates from other interfaces.
	IsParser_nameContext()
}

type Parser_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParser_nameContext() *Parser_nameContext {
	var p = new(Parser_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_parser_name
	return p
}

func InitEmptyParser_nameContext(p *Parser_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_parser_name
}

func (*Parser_nameContext) IsParser_nameContext() {}

func NewParser_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parser_nameContext {
	var p = new(Parser_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_parser_name

	return p
}

func (s *Parser_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Parser_nameContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Parser_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parser_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parser_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterParser_name(s)
	}
}

func (s *Parser_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitParser_name(s)
	}
}

func (p *CreateParser) Parser_name() (localctx IParser_nameContext) {
	localctx = NewParser_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CreateParserRULE_parser_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConnect_stringContext is an interface to support dynamic dispatch.
type IConnect_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsConnect_stringContext differentiates from other interfaces.
	IsConnect_stringContext()
}

type Connect_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConnect_stringContext() *Connect_stringContext {
	var p = new(Connect_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_connect_string
	return p
}

func InitEmptyConnect_stringContext(p *Connect_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_connect_string
}

func (*Connect_stringContext) IsConnect_stringContext() {}

func NewConnect_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Connect_stringContext {
	var p = new(Connect_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_connect_string

	return p
}

func (s *Connect_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Connect_stringContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Connect_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Connect_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Connect_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterConnect_string(s)
	}
}

func (s *Connect_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitConnect_string(s)
	}
}

func (p *CreateParser) Connect_string() (localctx IConnect_stringContext) {
	localctx = NewConnect_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CreateParserRULE_connect_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(653)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharset_nameContext is an interface to support dynamic dispatch.
type ICharset_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsCharset_nameContext differentiates from other interfaces.
	IsCharset_nameContext()
}

type Charset_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharset_nameContext() *Charset_nameContext {
	var p = new(Charset_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_charset_name
	return p
}

func InitEmptyCharset_nameContext(p *Charset_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_charset_name
}

func (*Charset_nameContext) IsCharset_nameContext() {}

func NewCharset_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charset_nameContext {
	var p = new(Charset_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_charset_name

	return p
}

func (s *Charset_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Charset_nameContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Charset_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charset_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charset_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterCharset_name(s)
	}
}

func (s *Charset_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitCharset_name(s)
	}
}

func (p *CreateParser) Charset_name() (localctx ICharset_nameContext) {
	localctx = NewCharset_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CreateParserRULE_charset_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_value
	return p
}

func InitEmptyValueContext(p *ValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_value
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitValue(s)
	}
}

func (p *CreateParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CreateParserRULE_value)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthContext is an interface to support dynamic dispatch.
type ILengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode

	// IsLengthContext differentiates from other interfaces.
	IsLengthContext()
}

type LengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthContext() *LengthContext {
	var p = new(LengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_length
	return p
}

func InitEmptyLengthContext(p *LengthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_length
}

func (*LengthContext) IsLengthContext() {}

func NewLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthContext {
	var p = new(LengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_length

	return p
}

func (s *LengthContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CreateParserDECIMAL_LITERAL, 0)
}

func (s *LengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterLength(s)
	}
}

func (s *LengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitLength(s)
	}
}

func (p *CreateParser) Length() (localctx ILengthContext) {
	localctx = NewLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CreateParserRULE_length)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.Match(CreateParserDECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbsolute_path_to_directoryContext is an interface to support dynamic dispatch.
type IAbsolute_path_to_directoryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsAbsolute_path_to_directoryContext differentiates from other interfaces.
	IsAbsolute_path_to_directoryContext()
}

type Absolute_path_to_directoryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbsolute_path_to_directoryContext() *Absolute_path_to_directoryContext {
	var p = new(Absolute_path_to_directoryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_absolute_path_to_directory
	return p
}

func InitEmptyAbsolute_path_to_directoryContext(p *Absolute_path_to_directoryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_absolute_path_to_directory
}

func (*Absolute_path_to_directoryContext) IsAbsolute_path_to_directoryContext() {}

func NewAbsolute_path_to_directoryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Absolute_path_to_directoryContext {
	var p = new(Absolute_path_to_directoryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_absolute_path_to_directory

	return p
}

func (s *Absolute_path_to_directoryContext) GetParser() antlr.Parser { return s.parser }

func (s *Absolute_path_to_directoryContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Absolute_path_to_directoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Absolute_path_to_directoryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Absolute_path_to_directoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterAbsolute_path_to_directory(s)
	}
}

func (s *Absolute_path_to_directoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitAbsolute_path_to_directory(s)
	}
}

func (p *CreateParser) Absolute_path_to_directory() (localctx IAbsolute_path_to_directoryContext) {
	localctx = NewAbsolute_path_to_directoryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CreateParserRULE_absolute_path_to_directory)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(661)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *CreateParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CreateParserRULE_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(663)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumContext is an interface to support dynamic dispatch.
type INumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIGTS() antlr.TerminalNode

	// IsNumContext differentiates from other interfaces.
	IsNumContext()
}

type NumContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumContext() *NumContext {
	var p = new(NumContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_num
	return p
}

func InitEmptyNumContext(p *NumContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_num
}

func (*NumContext) IsNumContext() {}

func NewNumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumContext {
	var p = new(NumContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_num

	return p
}

func (s *NumContext) GetParser() antlr.Parser { return s.parser }

func (s *NumContext) DIGTS() antlr.TerminalNode {
	return s.GetToken(CreateParserDIGTS, 0)
}

func (s *NumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterNum(s)
	}
}

func (s *NumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitNum(s)
	}
}

func (p *CreateParser) Num() (localctx INumContext) {
	localctx = NewNumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CreateParserRULE_num)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(665)
		p.Match(CreateParserDIGTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMax_number_of_rowsContext is an interface to support dynamic dispatch.
type IMax_number_of_rowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIGTS() antlr.TerminalNode

	// IsMax_number_of_rowsContext differentiates from other interfaces.
	IsMax_number_of_rowsContext()
}

type Max_number_of_rowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMax_number_of_rowsContext() *Max_number_of_rowsContext {
	var p = new(Max_number_of_rowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_max_number_of_rows
	return p
}

func InitEmptyMax_number_of_rowsContext(p *Max_number_of_rowsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_max_number_of_rows
}

func (*Max_number_of_rowsContext) IsMax_number_of_rowsContext() {}

func NewMax_number_of_rowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Max_number_of_rowsContext {
	var p = new(Max_number_of_rowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_max_number_of_rows

	return p
}

func (s *Max_number_of_rowsContext) GetParser() antlr.Parser { return s.parser }

func (s *Max_number_of_rowsContext) DIGTS() antlr.TerminalNode {
	return s.GetToken(CreateParserDIGTS, 0)
}

func (s *Max_number_of_rowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Max_number_of_rowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Max_number_of_rowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterMax_number_of_rows(s)
	}
}

func (s *Max_number_of_rowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitMax_number_of_rows(s)
	}
}

func (p *CreateParser) Max_number_of_rows() (localctx IMax_number_of_rowsContext) {
	localctx = NewMax_number_of_rowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CreateParserRULE_max_number_of_rows)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.Match(CreateParserDIGTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMin_number_of_rowsContext is an interface to support dynamic dispatch.
type IMin_number_of_rowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIGTS() antlr.TerminalNode

	// IsMin_number_of_rowsContext differentiates from other interfaces.
	IsMin_number_of_rowsContext()
}

type Min_number_of_rowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMin_number_of_rowsContext() *Min_number_of_rowsContext {
	var p = new(Min_number_of_rowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_min_number_of_rows
	return p
}

func InitEmptyMin_number_of_rowsContext(p *Min_number_of_rowsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_min_number_of_rows
}

func (*Min_number_of_rowsContext) IsMin_number_of_rowsContext() {}

func NewMin_number_of_rowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Min_number_of_rowsContext {
	var p = new(Min_number_of_rowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_min_number_of_rows

	return p
}

func (s *Min_number_of_rowsContext) GetParser() antlr.Parser { return s.parser }

func (s *Min_number_of_rowsContext) DIGTS() antlr.TerminalNode {
	return s.GetToken(CreateParserDIGTS, 0)
}

func (s *Min_number_of_rowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Min_number_of_rowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Min_number_of_rowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterMin_number_of_rows(s)
	}
}

func (s *Min_number_of_rowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitMin_number_of_rows(s)
	}
}

func (p *CreateParser) Min_number_of_rows() (localctx IMin_number_of_rowsContext) {
	localctx = NewMin_number_of_rowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CreateParserRULE_min_number_of_rows)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Match(CreateParserDIGTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartition_nameContext is an interface to support dynamic dispatch.
type IPartition_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsPartition_nameContext differentiates from other interfaces.
	IsPartition_nameContext()
}

type Partition_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_nameContext() *Partition_nameContext {
	var p = new(Partition_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_partition_name
	return p
}

func InitEmptyPartition_nameContext(p *Partition_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_partition_name
}

func (*Partition_nameContext) IsPartition_nameContext() {}

func NewPartition_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_nameContext {
	var p = new(Partition_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_partition_name

	return p
}

func (s *Partition_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_nameContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Partition_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterPartition_name(s)
	}
}

func (s *Partition_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitPartition_name(s)
	}
}

func (p *CreateParser) Partition_name() (localctx IPartition_nameContext) {
	localctx = NewPartition_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CreateParserRULE_partition_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogical_nameContext is an interface to support dynamic dispatch.
type ILogical_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsLogical_nameContext differentiates from other interfaces.
	IsLogical_nameContext()
}

type Logical_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_nameContext() *Logical_nameContext {
	var p = new(Logical_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_logical_name
	return p
}

func InitEmptyLogical_nameContext(p *Logical_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_logical_name
}

func (*Logical_nameContext) IsLogical_nameContext() {}

func NewLogical_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_nameContext {
	var p = new(Logical_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_logical_name

	return p
}

func (s *Logical_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_nameContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Logical_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterLogical_name(s)
	}
}

func (s *Logical_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitLogical_name(s)
	}
}

func (p *CreateParser) Logical_name() (localctx ILogical_nameContext) {
	localctx = NewLogical_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CreateParserRULE_logical_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(673)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IData_dirContext is an interface to support dynamic dispatch.
type IData_dirContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsData_dirContext differentiates from other interfaces.
	IsData_dirContext()
}

type Data_dirContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_dirContext() *Data_dirContext {
	var p = new(Data_dirContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_data_dir
	return p
}

func InitEmptyData_dirContext(p *Data_dirContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_data_dir
}

func (*Data_dirContext) IsData_dirContext() {}

func NewData_dirContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_dirContext {
	var p = new(Data_dirContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_data_dir

	return p
}

func (s *Data_dirContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_dirContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Data_dirContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_dirContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_dirContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterData_dir(s)
	}
}

func (s *Data_dirContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitData_dir(s)
	}
}

func (p *CreateParser) Data_dir() (localctx IData_dirContext) {
	localctx = NewData_dirContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CreateParserRULE_data_dir)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(675)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_dirContext is an interface to support dynamic dispatch.
type IIndex_dirContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode

	// IsIndex_dirContext differentiates from other interfaces.
	IsIndex_dirContext()
}

type Index_dirContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_dirContext() *Index_dirContext {
	var p = new(Index_dirContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_index_dir
	return p
}

func InitEmptyIndex_dirContext(p *Index_dirContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_index_dir
}

func (*Index_dirContext) IsIndex_dirContext() {}

func NewIndex_dirContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_dirContext {
	var p = new(Index_dirContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_index_dir

	return p
}

func (s *Index_dirContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_dirContext) ID() antlr.TerminalNode {
	return s.GetToken(CreateParserID, 0)
}

func (s *Index_dirContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_dirContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_dirContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterIndex_dir(s)
	}
}

func (s *Index_dirContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitIndex_dir(s)
	}
}

func (p *CreateParser) Index_dir() (localctx IIndex_dirContext) {
	localctx = NewIndex_dirContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CreateParserRULE_index_dir)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(677)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_listContext is an interface to support dynamic dispatch.
type IColumn_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCol_name() []ICol_nameContext
	Col_name(i int) ICol_nameContext
	AllColumn_definition() []IColumn_definitionContext
	Column_definition(i int) IColumn_definitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumn_listContext differentiates from other interfaces.
	IsColumn_listContext()
}

type Column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_listContext() *Column_listContext {
	var p = new(Column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_column_list
	return p
}

func InitEmptyColumn_listContext(p *Column_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_column_list
}

func (*Column_listContext) IsColumn_listContext() {}

func NewColumn_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_listContext {
	var p = new(Column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_column_list

	return p
}

func (s *Column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_listContext) AllCol_name() []ICol_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICol_nameContext); ok {
			len++
		}
	}

	tst := make([]ICol_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICol_nameContext); ok {
			tst[i] = t.(ICol_nameContext)
			i++
		}
	}

	return tst
}

func (s *Column_listContext) Col_name(i int) ICol_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICol_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICol_nameContext)
}

func (s *Column_listContext) AllColumn_definition() []IColumn_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_definitionContext); ok {
			len++
		}
	}

	tst := make([]IColumn_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_definitionContext); ok {
			tst[i] = t.(IColumn_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Column_listContext) Column_definition(i int) IColumn_definitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definitionContext)
}

func (s *Column_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CreateParserCOMMA)
}

func (s *Column_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMA, i)
}

func (s *Column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterColumn_list(s)
	}
}

func (s *Column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitColumn_list(s)
	}
}

func (p *CreateParser) Column_list() (localctx IColumn_listContext) {
	localctx = NewColumn_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CreateParserRULE_column_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.Col_name()
	}
	{
		p.SetState(680)
		p.Column_definition()
	}
	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CreateParserCOMMA {
		{
			p.SetState(681)
			p.Match(CreateParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(682)
			p.Col_name()
		}
		{
			p.SetState(683)
			p.Column_definition()
		}

		p.SetState(689)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValue_listContext is an interface to support dynamic dispatch.
type IValue_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValue_listContext differentiates from other interfaces.
	IsValue_listContext()
}

type Value_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_listContext() *Value_listContext {
	var p = new(Value_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_value_list
	return p
}

func InitEmptyValue_listContext(p *Value_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CreateParserRULE_value_list
}

func (*Value_listContext) IsValue_listContext() {}

func NewValue_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_listContext {
	var p = new(Value_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CreateParserRULE_value_list

	return p
}

func (s *Value_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_listContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(CreateParserID)
}

func (s *Value_listContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserID, i)
}

func (s *Value_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(CreateParserCOMMA)
}

func (s *Value_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(CreateParserCOMMA, i)
}

func (s *Value_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.EnterValue_list(s)
	}
}

func (s *Value_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CreateParserListener); ok {
		listenerT.ExitValue_list(s)
	}
}

func (p *CreateParser) Value_list() (localctx IValue_listContext) {
	localctx = NewValue_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CreateParserRULE_value_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(CreateParserID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(691)
				p.Match(CreateParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(692)
				p.Match(CreateParserID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
